## 基础知识

ARM架构（Advanced RISC Machine）是一种处理器架构

### ==特点和优势==

- `简化指令集`：ARM采用精简指令集（RISC, Reduced Instruction Set Computer），指令集简单且易于解码和执行，使得处理器设计更加高效。
  - `低功耗设计`：ARM架构在设计上注重低功耗特性，使得ARM处理器能够在电池供电的移动设备上实现较长的续航时间。
  - `高性能`：尽管ARM架构着重于低功耗设计，但它也能提供出色的性能。ARM处理器通过多核设计、高频率运行和高级优化技术，实现了高效的计算能力。
  - `可扩展性`：ARM架构具有良好的可扩展性，可以应用于不同的设备和应用领域。从低端的嵌入式系统到高端的服务器，ARM处理器都能够满足各种需求。
  - `软件生态系统`：ARM架构享有广泛的软件生态系统支持。许多操作系统（如Android、iOS）和应用程序已经针对ARM架构进行了优化，使得ARM处理器成为移动设备的首选。
  - `设计定制性`：ARM架构提供了灵活的设计定制选项，使得芯片制造商能够根据特定应用的需求进行定制和优化，从而实现更好的性能和功耗平衡。

### ==CPU、MCU、SOC区别==

- CPU：运算器、控制器、寄存器组成，主要负责取指、放入寄存器、译码、执行指令并更新寄存器（仅存在理论之中）
- MPU：增强版的CPU
- MCU：CPU+RAM+ROM+I/O，在CPU的基础上加入片上RAM、Flash、串口、ADC等外设，在一块芯片上集成整个计算机系统
- SOC：MPU+RAM+ROM+I/O+特定功能模块（如电能计量、编解码），将MPU的计算能力和MCU的外设结合

### ==MCU加载程序方式==

以XIP （eXecute In Place）的方式在 Flash 中运行程序，而不是搬运到 RAM 中

- 节省内存空间：MCU 往往具有较小的内存容量，特别是 RAM 的容量较有限。使用 XIP 可以避免将程序复制到 RAM 中造成内存空间的占用，从而节省了宝贵的 RAM 空间，可以将 RAM 用于其他需要快速存取的数据。
- 成本优势：RAM 往往比 Flash 的价格更高，因此将程序直接运行在 Flash 中可以降低系统成本。在 MCU 中，Flash 往往是固化在芯片内部的，而 RAM 需要额外的外部芯片或部件支持，增加了系统的复杂性和成本。
- 提高读取速度：Flash 存储器通常具有较快的访问速度，对于微控制器来说，执行程序时可能已经足够快。在 XIP 模式下，不需要将程序从 Flash 复制到 RAM，节省了在复制过程中的时间，可以直接在 Flash 中运行，加快了程序的启动时间和响应速度。
- 适用于嵌入式系统：MCU 往往嵌入在一些资源受限、功耗要求较低的嵌入式系统中。使用 XIP 可以减少对外部 RAM 的需求，降低功耗，并且提高系统整体的稳定性和可靠性。

尽管 XIP 有以上的优势，它仍然存在一些限制和考虑因素，例如访问延迟较高、不适用于频繁写操作的场景等。因此在设计 MCU 的时候需要综合考虑具体的应用场景和需求来选择合适的存储方案。

### ==存储器层次结构与分类==

![在这里插入图片描述](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/20210528110828244.png)

- Cache

  高速     中等速度   低速

  CPU <------> Cache <-----> RAM

  Cache，就是一种缓存机制，它位于CPU和DDR RAM之间，为CPU和DDR之间的读写提供一段内存缓冲区。cache一般是SRAM，它采用了和制作CPU相同的半导体工艺，它的价格比DDR要高，但读写速度要比DDR快不少。例如CPU要执行DDR里的指令，可以一次性的读一块区域的指令到cache里，下次就可以直接从cache里获取指令，而不用反复的去访问速度较慢的DDR。又例如，CPU要写一块数据到DDR里，它可以将数据快速地写到cache里，然后手动执行一条刷新cache的指令就可以将这片数据都更新到DDR里，或者干脆就不刷新，待cache到合适的时候，自己再将内容flush到DDR里。总之一句话，cache的存在意义就是拉近CPU和DDR直接的性能差异，提高整个系统性能。

  Cache分为I-Cache（指令缓存）与D-Cache（数据缓存）

  ![在这里插入图片描述](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/20210528111327990.png)

  cache是多级的，在一个系统中你可能会看到L1、L2、L3, 当然越靠近core就越小，也是越昂贵。

  CPU接收到指令后，它会最先向CPU中的一级缓存（L1 Cache）去寻找相关的数据，然一级缓存是与CPU同频运行的，但是由于容量较小，所以不可能每次都命中。这时CPU会继续向下一级的二级缓存（L2 Cache）寻找，同样的道理，当所需要的数据在二级缓存中也没有的话，会继续转向L3 Cache、内存(主存)和硬盘.

  ![在这里插入图片描述](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/9a20a239133a43e8b307e2ac08e7db8b.png)

  不能使用cache的情况

  1. CPU读取外设的内存数据，如果外设的数据本身会变，如网卡接收到外部数据，那么CPU如果连续2次读外设的操作相差时间很短，而且访问的是同样的地址，上次的内存数据还存在于cache当中，那么CPU第二次读取的可能还是第一次缓存在cache里数据。
  2. CPU往外设写数据，如向串口控制器的内存空间写数据，如果CPU第1次写的数据还存在于cache当中，第2次又往同样的地址写数据，CPU可能就只更新了一下cache，由cache输出到串口的只有第2次的内容，第1次写的数据就丢失了。
  3. 在嵌入式开发环境中，经常需要在PC端使用调试工具来通过直接查看内存的方式以确定某些事件的发生，如果定义一个全局变量来记录中断计数或者task循环次数等，这个变量如果定义为cache的，你会发现有时候系统明明是正常运行的，但是这个全局变量很长时间都不动一下。其实它的累加效果在cache里，因为没有人引用该变量，而长时间不会flush到DDR里
  4. 考虑双cpu的运行环境(不是双核)。cpu1和cpu2共享一块ddr，它们都能访问,这块共享内存用于处理器之间的通信。cpu1在写完数据到后立刻给cpu2一个中断信号，通知cpu2去读这块内存，如果用cache的方法，cpu1可能把更新的内容只写到cache里，还没有被换出到ddr里，cpu2就已经跑去读，那么读到的并不是期望的数据。

  ![image-20230607151630997](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230607151630997.png)

  - 为何启动时关闭Cache

  在嵌入式系统和某些应用程序中，启动时关闭指令缓存（Instruction Cache）和数据缓存（Data Cache）是一种常见的做法。以下是一些原因：

  1. 避免缓存冲突：在启动阶段，代码和数据通常是从外部存储器（如闪存）加载到内部存储器（如RAM）中。由于这些加载过程往往涉及重复的读写操作，启动时关闭缓存可以防止缓存中的“旧”数据对加载过程产生冲突，确保正确加载并执行新的代码和数据。
  2. 简化启动过程：在关闭缓存的情况下，处理器将直接从内存中读取指令和数据，而不依赖于缓存。这样可以避免额外的缓存管理开销，并简化启动代码的编写和调试过程。
  3. 确保数据的一致性：某些应用程序要求数据在内存和外部设备之间保持一致。在关闭缓存的情况下，每次访问数据都将直接从内存取，确内存中的数据始终与外部设备保持一致，关闭存并不适用于所有应用场景，并且可能会对性能产生负面影响。在实际应用中，应根据具体的系统需求和性能要求来决定是否关闭缓存。

- Nor Flash Nand Flash

  - NoR Flash中不仅可以存储数据，且可以取指运行(XIR)，也就是MCU给出地址，Nor可以直接返回指令交给MCU去执行，这样不用把指令拷贝到RAM里去执行；
  - NAND Flash仅可用于存储，取值时需要搬运到RAM中


### ==ARM处理器的体系结构==

- 处理器模式：ARM处理器有多个处理器模式，每个模式用于执行不同类型的任务。常见的处理器模式包括：
  - 用户模式（User Mode）：用户模式是一种常规模式，用于执行应用程序。在用户模式下，处理器的权限较低，无法直接执行特权指令或访问受保护的系统资源。它是最受限制的模式。SVC（Supervisor Call）指令可以从用户模式切换到管理模式，SWI（Software Interrupt）指令可以从用户模式切换到中断模式。
  - 系统模式（System Mode）：运行具有特权的操作系统任务。
  - 管理模式（Supervisor mode）：操作系统使用的保护模式。在系统复位或执行软件中断指令SWI时进入。
  - 中止模式（Abort mode）：当数据或指令预取终止时进入该模式，可用于虚拟存储及存储保护。
  - 未定义模式（Undefined mode）：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。
  - 快速中断模式（FIQ mode）：用于高速数据传输或通道处理。
  - 外部中断模式（IRQ mode）：用于通用的中断处理。
  - 模式（Hyp mode）：用于虚拟化环境中的虚拟化监管。
- 寄存器：ARM处理器有多个寄存器，用于存储和处理数据。常见的寄存器包括：
  - 通用寄存器（General-Purpose Registers）：用于存储临时数据和计算结果。
  - 程序计数器（Program Counter，PC）：存储当前正在执行的指令的地址。
  - 程序状态寄存器（Current Program Status Register, CPSR）：存储处理器的状态信息，如处理器模式、中断使能等。
  - 程序状态保存寄存器（Saved Program Status Registers, SPSR）：当异常发生时，用于存储CPSR信息。
- 指令集：ARM处理器使用ARM指令集和Thumb指令集。
  - ARM指令集包含32位的指令，提供了丰富的功能和灵活性。
  - Thumb指令集支持16位的指令，用于提高代码密度和节省存储空间。
  - 最新的ARM处理器还支持AArch64执行状态，提供了64位的指令集，称为AArch64指令集。

### ==冯诺依曼与哈弗体系结构==

冯‘诺依曼体系：计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成

|         体系         |   冯诺依曼    |                哈佛                |                    改进的哈佛（现代ARM）                     |
| :------------------: | :-----------: | :--------------------------------: | :----------------------------------------------------------: |
|  数据与程序存储方式  |  存储在一起   |              分开存储              |                           分开存储                           |
|     CPU总线条数      | 1*(地址+数据) |           2*(地址+数据)            | 1*(地址+数据)（新增cache，cpu由1条总线读cache，cache有2条总线） |
| 取指操作与取数据操作 |     串行      |           并行，可预取指           |                        并行，可预取指                        |
|         缺点         |    成本低     |               成本高               |                             综合                             |
|         优点         |  执行效率低   | 效率高，流水线（取指、译码、执行） |                            同哈佛                            |

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/SouthEast.png" alt="这里写图片描述" style="zoom: 33%;" /><img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/SouthEast-166701102120110.png" alt="这里写图片描述" style="zoom: 33%;" /><img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/SouthEast-166701103111813.png" alt="这里写图片描述" style="zoom: 33%;" />



### ==ARM架构与x86架构区别==

- 最主要区别：指令集

  - ARM：精简指令集RISC

  - X86：复杂指令集CISC


- 功耗

  - ARM：主要面向低功耗

  - X86：通过制程弥补功耗劣势


- 性能
  - ARM：低性能，顺序执行能力强，流水线指令集，主频低于1G
  - X86：高性能，乱序执行能力强，主频高

### ==ARM的异常处理机制==

- 中断和异常的区别：

  - `中断（Interrupt）`是由外部设备或事件引发的中断请求，用于打断正在执行的指令流，让处理器转移到中断服务程序（Interrupt Service Routine，ISR）来处理该事件。中断通常由外部设备的信号触发，例如定时器溢出、外部设备的输入等。
  - `异常（Exception）`是由程序运行过程中的异常情况引发的事件，如无效的指令、访问越界、除以零等。异常会导致处理器从当前模式切换到异常模式，并执行异常处理程序（Exception Handler）来处理异常情况。

- 异常处理过程：

  - 当发生异常时，处理器会保存当前的上下文信息（如寄存器状态、程序计数器等），以便稍后恢复执行。
  - 处理器会根据异常类型和优先级判断是否响应该异常，如果需要响应，则会切换到异常模式，并跳转到相应的异常处理程序。
  - 异常处理程序会执行相关的异常处理逻辑，如错误处理、状态恢复、错误日志记录等。
  - 在处理完异常后，处理器会从保存的上下文信息中恢复状态，并回到原来的模式和指令流中，继续执行。

- ARM中断控制器

  - 根据优先级和配置信息将中断信号传递给处理器核心。

      1. 外部设备发出中断请求信号，例如一个键盘按键被按下。
      2. 中断控制器接收到中断请求信号，并根据预先配置的中断优先级判断该中断的优先级。
      3. 如果该中断的优先级高于当前正在处理的中断，中断控制器将中断请求传递给处理器核心。
      4. 处理器核心响应中断，暂停当前的指令执行，并跳转到中断处理程序的入口地址。
      5. 中断处理程序执行相应的处理操作，例如读取键盘输入数据。
      6. 处理完成后，中断处理程序返回到中断发生前的指令位置，恢复之前的执行状态。
      7. 中断控制器通知处理器中断处理结束，并可以选择响应下一个优先级较高的中断请求。

### ==ARM的Cache和MMU==

- `Cache`：Cache是一种位于处理器和主存之间的高速存储器，用于存储最近使用的数据和指令。它的作用是通过预先将数据和指令复制到快速的缓存中，加快对数据的访问速度，减少对主存的访问次数。Cache的工作原理是基于局部性原理，即程序和数据的访问往往呈现出一定的空间局部性和时间局部性。Cache通过存储最近使用的数据块，以便在后续的访问中快速提供数据，减少了对主存的延迟。
  - `MMU`:MMU是负责管理虚拟内存和物理内存之间映射关系的组件。它允许操作系统和应用程序使用虚拟内存地址，而不必关心物理内存的实际分配情况。MMU的主要功能包括地址转换和内存保护。它通过将虚拟地址转换为物理地址，实现了对虚拟内存的透明访问。MMU还负责内存保护，通过访问控制和权限设置，确保不同应用程序之间的内存隔离和安全性。MMU还支持内存映射技术，例如页面映射（Page Mapping）和段映射（Segment Mapping），以及虚拟内存的分页和分段机制，实现了灵活的内存管理和资源分配。

### ==ARM协处理器和向量处理器==

- `协处理器（Coprocessor）`：协处理器是ARM处理器的一个可选扩展，用于执行特定的处理任务。它是与主处理器并行工作的一个辅助处理器。协处理器可以执行一些特定的指令和操作，例如浮点运算、加密算法、信号处理等。通过将特定任务分配给协处理器，ARM处理器可以提高处理性能和效率。
  - `向量处理器（NEON）`：NEON是ARM处理器中的一个向量处理器扩展，用于高效执行并行的多媒体和信号处理操作。NEON提供了一组特定的指令和寄存器，用于同时处理多个数据元素，例如矢量、矩阵和像素数据。这使得ARM处理器能够高效地执行诸如图像处理、音频处理、视频编解码等计算密集型任务。

### ==ARM管道流水线==

- ARM处理器的管道流水线是一种用于提高指令执行效率的技术。它将指令执行过程划分为多个阶段，并在每个阶段引入寄存器，使得多条指令可以同时在不同的阶段执行。这样可以提高处理器的吞吐量，使得指令能够更快地完成执行。
- 流水线中的不同阶段包括：
  
  - 取指（Instruction Fetch）：从内存中获取下一条指令。
  - 译码（Instruction Decode）：将指令解析成对应的操作码和操作数，并为执行阶段做准备。
  - 执行（Execute）：执行指令的具体操作，如算术运算、逻辑运算等。
  - 访存（Memory Access）：如果指令需要访问内存，这个阶段用于进行数据的读取或写入操作。
  - 写回（Write Back）：将执行结果写回到寄存器中，更新寄存器的内容。
  
- 通过流水线技术，当一条指令执行进入流水线后，后续的指令可以继续进入流水线的不同阶段，从而实现指令级并行（Instruction-Level Parallelism）。这可以提高处理器的效率，使得多条指令可以在同一时间段内重叠执行。
- 一个任务执行阶段，开始下一个任务的取指、译码阶段

  - 提高了吞吐量，但单任务的执行时间没有减少
  - 受制于最慢的流水线
  - 对程序员不可见

  RISC5级流水线步骤

  1. 取指（访问Icache得到PC）
  2. 译码（翻译指令并从寄存器取数）
  3. 执行（运算）
  4. 访存（访问存储器，读取操作数）（4级流水线独有）
  5. 写回（将结果写回寄存器）（5级流水线独有）

  ARM3级流水线步骤

  1. 取指
  2. 译码
  3. 执行

### ==ARM访存模型和虚拟内存==

- ARM的访存模型：ARM处理器采用了一种称为“Harvard结构”的访存模型，其中指令和数据分别存储在不同的内存空间中。 中央处理器首先到程序指令储存器中读取程序指令内容，解码后得到数据地址，再到相应的数据储存器中读取数据，并进行下一步的操作（通常是执行）。程序指令储存和数据储存分开，数据和指令的储存可以同时进行，可以使指令和数据有不同的数据宽度，
  - 与虚拟内存的关系：ARM处理器与虚拟内存之间的关系是通过内存管理单元（MMU）来实现的。MMU负责将程序中的虚拟地址转换为物理地址。在访问内存时，ARM处理器使用虚拟地址进行操作，然后MMU根据映射表（Page Table）将虚拟地址转换为物理地址。这种地址转换的过程是透明的，程序无需关心物理内存的实际布局。

### ==浮点单元==

- ARM处理器的浮点运算支持是通过`浮点单元（Floating-Point Unit，FPU）`来实现的。FPU是一个硬件模块，专门用于执行浮点运算，包括浮点加减、乘除、取整等操作。

### ==ARM功耗管理机制==

- `动态电压频率调节（Dynamic Voltage and Frequency Scaling，DVFS）`：DVFS允许处理器根据负载需求动态调整工作频率和电压。当处理器需要更高的性能时，可以增加工作频率和电压；当处理器处于轻负载或空闲状态时，可以降低工作频率和电压以降低功耗。
  - `休眠状态和低功耗模式`：处理器可以进入休眠状态或低功耗模式，在这些状态下，处理器的工作频率和电压会被降低到最低限度，以节省功耗。当处理器再次需要被唤醒时，会恢复到正常工作状态。
  - `智能缓存和预取机制`：处理器的缓存和预取机制可以提高数据访问效率，减少对主存的访问次数，从而降低功耗。智能缓存能够预测和缓存可能的数据访问模式，以提供更高的数据命中率和更低的功耗。
  - `功耗优化的指令调度和执行`：处理器在指令调度和执行时可以采取一些技术来降低功耗。例如，乱序执行（Out-of-order Execution）可以在不影响程序正确性的前提下重排指令的执行顺序，以优化资源利用和降低功耗。
  - `硬件加速器和专用引擎`：一些ARM处理器集成了硬件加速器和专用引擎，用于执行特定的计算任务（如加密、解压缩等），这些加速器和引擎通常比通用处理器更高效，可以降低功耗。
  - `功耗分析和优化工具`：ARM提供了各种功耗分析和优化工具，开发人员可以使用这些工具来评估和优化处理器的功耗。这些工具可以帮助开发人员识别功耗热点、优化算法和代码，从而降低功耗。

### ==ARM的片上总线==

- `AMBA（Advanced Microcontroller Bus Architecture）`是由ARM公司提出的一种片上总线协议和架构。它定义了一组标准接口和通信协议，用于连接和协调处理器内部的不同模块和外设。AMBA提供了一种灵活、可扩展和可重用的总线架构，使得不同模块和外设能够有效地进行数据传输和通信。它通过规范化接口和传输协议，简化了系统设计和集成的复杂性。
- AHB是一种高性能、低延迟的总线，用于连接高带宽和关键性能的模块，如处理器和高速存储器。
- APB是一种低带宽、低功耗的总线，用于连接较简单的外设，如GPIO（通用输入输出）和串口控制器。
- AXI是一种高性能、高带宽的总线，用于连接处理器、内存和高性能外设。它支持多主机、多从机配置，并具有更高的并行性和流水线能力。
- ACE是AMBA 4协议的扩展版本，用于支持多核处理器系统中的一致性和高性能通信

## cortex

### ==M0系列芯片系统框图==

![M0系统框图](a_assets\cortex-m0系统框图.png)

![M3系统框图](a_assets\cortex-m3系统框图.png)

* 系统中包括：
  * 中断控制器
  * M0内核
  * AHB总线
  * 存储器和外设
  * 电源管理
  * 时钟树
  * 调试系统
* Cortex‐M3 支持大量异常,包括 16‐4‐1=11 个系统异常,和最多 240 个外部中断——简称 IRQ。
* Cortex‐M3 有一个可选的存储器保护单元（MPU）。配上它之后,就可以对特权级访问和用户级访问分别施加不同的访问限制。当检测到犯规(violated)时,MPU 就会产生一个 fault 异常,可以由 fault异常的服务例程来分析该错误,并且在可能时改正它。MPU 有很多玩法。最常见的就是由操作系统使用 MPU,以使特权级代码的数据,包括操作系统本身的数据不被其它用户程序弄坏。MPU 在保护内存时是按区管理的(“区”的原文是 region,以后不再中译此名词——译注)。它可以把某些内存 region 设置成只读,从而避免了那里的内容意外被更改;还可以在多任务系统中把不同任务之间的数据区隔离。一句话,它会使嵌入式系统变得更加健壮,更加可靠(很多行业标准,尤其是航空的,就规定了必须使用 MPU 来行使保护职能——译注)。
* Cortex‐M3 多了basepri寄存器可以阻止某优先级或更低的优先级的中断。faultmask寄存器提供了更多的错误管理特性。CONTROL寄存器的bit0用于决定是特权模式还是用户线程模式

### ==寄存器==

- 通用寄存器（有 R0~R15 共 16 个通用寄存器组和若干特殊功能寄存器）

<table>
    <tr>
        <td>R0</td>
        <td>R1</td>
        <td>R2</td>
        <td>R3</td>
        <td>R4</td>
        <td>R5</td>
        <td>R6</td>
        <td>R7</td>
        <td>R8</td>
        <td>R9</td>
        <td>R10</td>
        <td>R11</td>
        <td>R12</td>
    </tr>
</table>

- m0特殊寄存器

<table>
    <tr>
        <td>SP(R13)栈顶</td>
        <td>LR(R14)函数调用返回地址</td>
        <td>PC(R15)下一条指令</td>
        <td>CONTROL</td>
        <td>xPSR</td>
        <td>PRIMASK</td>
    </tr>
</table>


- m3/m4/m7特殊寄存器

<table>
    <tr>
        <td>SP(R13)</td>
        <td>LR(R14)</td>
        <td>PC(R15)</td>
        <td>CONTROL</td>
        <td>xPSR</td>
        <td>PRIMASK</td>
        <td>FAULTMASK</td>
        <td>BASEPRI</td>
    </tr>
</table>

- MSP的含义是Main_Stack_Pointer，即主栈
    PSP的含义是 Process_Stack_Pointer,即任务栈

    - Cortex-M3内核中有两个堆栈指针（MSP & PSP），但任何时刻只能使用到其中一个。
    - 复位后处于线程模式特权级，默认使用MSP。
    - 通过SP访问到的是正在使用的那个指针，可以通过MSR/MRS指令访问指定的堆栈指针。
    - 通过设置CONTROL寄存器的bit[1]选择使用哪个堆栈指针。CONTROL[1]=0选择主堆栈指针；CONTROL[1]=1选择进程堆栈指针。
    - Handler模式下，只允许使用主堆栈指针MSP。

    典型的OS环境中，MSP和PSP的用法如下：

    - MSP用于OS内核和异常处理。
    - PSP用于应用任务。
    - CONTROL的bit1为0，SP = MSP
      CONTROL的bit1为1，SP = PSP

    在裸机开发中，CONTROL的bit1始终是0，也就是说裸机开发中全程使用程MSP，并没有使用PSP。在执行后台程序(大循环程序)SP使用的是MSP，在执行前台程序(中断服务程序)SP使用的是MSP。
    在OS开发中，当运行中断服务程序的时候CONTROL的bit1是0，SP使用的是MSP；当运行线程程序的时候CONTROL的bit1是1，SP使用的是PSP。

    <img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/77adfd6d116646938be68957e77dc2b1.png" alt="在这里插入图片描述" style="zoom: 50%;" />

    ![img](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/333765-20190729152749256-654379342.jpg)

    初始化时的操作

    - 系统复位时从0x00000000处读出MSP的初始值。
    - 在OS初始化时，对PSP进行初始化。

    ![img](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/333765-20190729153022824-1935836660.jpg)

    任务调度时的操作

    - 用任务A的SP执行入栈操作，并保存任务A的SP。
    - 设置PSP指向任务B的栈空间，用任务B的SP执行出栈，随后开始执行任务B。

    ![img](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/333765-20190729153108482-487805476.jpg)

- MSP和PSP

    msp中断中会使用，psp用于线程栈使用，通过配置CONTROL寄存器切换。
    系统复位后默认使用msp，中断中也使用msp。

- xPSR

    IPSR可以用来判断当前处于什么中断。

- PRIMASK

    中断屏蔽寄存器，写1屏蔽所有中断(除了不可屏蔽中断和hardfault)

- CONTROL

    第1bit写1表示切换成PSP

- FAULTMASK

屏蔽所有的fault (NMI不受影响)

- BASEPRI

屏蔽所有优先级不高于某个具体数值的中断

- NVIC可嵌套向量中断控制器

  * 中断可嵌套、相同优先级的中断不可嵌套、相同中断不可嵌套

    | 地址                    | 寄存器名称 | 说明                 |
    | ----------------------- | :--------: | -------------------- |
    | 0xE000E100              |    ISER    | 中断使能寄存器       |
    | 0xE000E180              |    ICER    | 中断失能寄存器       |
    | 0xE000E200              |    ISPR    | 中断挂起寄存器       |
    | 0xE000E280              |    ICPR    | 清除挂起中断的寄存器 |
    | 0xE000E400 - 0xE000E41C |   IPR0-7   | 中断优先级配置寄存器 |

- 系统操作寄存器

  | 地址范围                | 寄存器说明                 |
  | ----------------------- | -------------------------- |
  | 0xE000E008 - 0xE000E00F | System Control Block Table |
  | 0xE000E010 - 0xE000E01F | 预留                       |
  | 0xE000E010 - 0xE000E01F | SysTick操作寄存器          |
  | 0xE000E100 - 0xE000E4EF | NVIC操作寄存器             |
  | 0xE000ED00 - 0xE000ED3F | 系统控制块                 |
  | 0xE000EF00 - 0xE000EF03 | NVIC                       |

- 系统控制块SCB寄存器

  | 地址       | 寄存器名称 | 说明                               |
  | ---------- | :--------: | ---------------------------------- |
  | 0xE000ED00 |   CPUID    | CPUID                              |
  | 0xE000ED04 |    ICSR    | 中断控制和状态寄存器               |
  | 0xE000ED0C |   AIRCR    | 应用中断和复位的寄存器             |
  | 0xE000ED10 |    SCR     | 系统控制寄存器                     |
  | 0xE000ED14 |    CCR     | 配置控制寄存器                     |
  | 0xE000ED1C |   SHPR2    | System Handler Priority Register 2 |
  | 0xE000ED20 |   SHPR3    | System Handler Priority Register 3 |

- SysTick寄存器

  | 地址       | 寄存器名称 | 说明                    |
  | ---------- | :--------: | ----------------------- |
  | 0xE000E010 |  SYST_CSR  | SysTick控制和状态寄存器 |
  | 0xE000E014 |  SYST_RVR  | SysTick重载寄存器       |
  | 0xE000E018 |  SYST_CVR  | SysTick当前值寄存器     |
  | 0xE000E01C | SYST_CALIB | SysTick校准寄存器       |

### ==系统异常与中断==

| 异常类型  | 异常编号 | 说明               |
| --------- | :------: | ------------------ |
| reset     |    1     | 上电复位、系统复位 |
| NMI       |    2     | 不可屏蔽中断       |
| hardfault |    3     | 硬件错误           |
| SVCall    |    11    | 系统调用           |
| PendSV    |    13    | 挂起系统调用       |
| systick   |    15    | 系统滴答           |

Cortex-M3和M4中断屏蔽寄存器有三种

- PRIMASK
- FAULTMASK
- BASEPRI

1. PRIMASK寄存器设置为1后，关闭所有中断和除了HardFault异常外的所有其他异常，只有**NMI、Reset和HardFault可以得到响应**。

```assembly
CPSIE I;                                        // 清除PRIMASK（使能中断）
CPSID I;                                        // 设置PRIMASK（禁止中断）
```

2. FAULTMASK寄存器会把异常的优先级提升到-1，设置为1后关闭所有中断和异常，包括HardFault异常，只有**NMI和Reset可以得到响应**。

```assenbly
CPSIE F;                        // 清除FAULTMASK
CPSID F;                        // 设置FAULTMASK
```

3. BASEPRI寄存器可以屏蔽低于某一个阈值的中断。设置为n后，屏蔽所有优先级数值大于等于n的中断和异常。Cortex-M的优先级数值越大其优先级越低。

### ==M0启动流程==

- 程序从0x00000000地址开始执行
- m0从程序bin文件的开始处第2个word运行reset_handler
- reset_handler函数开始执行一些必要的初始化（ramfunc函数复制，堆初始化，全局、静态变量初始化等）
- 跳转到main函数中

### ==压栈寄存器==

<table>
    <tr><td>xPSR</td></tr>
    <tr><td>PC</td></tr>
    <tr><td>LR</td></tr>
    <tr><td>R12</td></tr>
    <tr><td>R3</td></tr>
    <tr><td>R2</td></tr>
    <tr><td>R1</td></tr>
    <tr><td>R0</td></tr>
</table>