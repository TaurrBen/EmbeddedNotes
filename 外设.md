# STM32启动流程

1.依据boot引脚选择启动区域

| 引脚 | 启动方式   | 描述                                           |
| ---- | ---------- | ---------------------------------------------- |
| x 0  | 片内Flash  | 代码区启动，ICP下载（SWD、JTAG烧录）           |
| 0 1  | 系统存储器 | 内置ROM启动，ISP下载（出厂预置代码，UART烧录） |
| 1 1  | SRAM       | RAM启动，掉电丢失                              |

2.运行bootloader

![在这里插入图片描述](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjc3ODE1,size_16,color_FFFFFF,t_70%23pic_center.png)

​	处理器会将各个寄存器的值初始化为默认值

​	2.1 硬件设置SP、PC，进入复位中断函数Rest_Hander()

​		从0x0800 0000读取数据赋值给栈指针SP(MSP)，设置为栈顶指针0x2000 0000+RAM_Size

​		从0x0800 0004读取数据赋值给PC（指向Reset_Handler中断服务函数）

```c
LDR R0, = SystemInit
BLX R0 
```

​	2.2 设置系统时钟，进入SystemInit()

​		设置RCC寄存器各位

​		设置中断向量表偏移地址

```c
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
#endif 
```

​	2.3 软件设置SP，__main入栈（统初始化函数）

```c
LDR R0,=__main
BX R0
```

​	2.4 加载data、bss段并初始化_main栈区

​		拷贝Flash中的数据进入SRAM（哈弗体系结构决定了：数据与代码分开存储）

​		![在这里插入图片描述](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/0ea95a362db5457185191faf18069262.png)

3 跳转到main()

![img](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/v2-1224644e63357ad886348dd630d9bce7_720w.webp)

![image-20230714215157086](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230714215157086.png)



## OTA的情况

![image-20230714215350653](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230714215350653.png)

在FLASH中添加引导程序后，其与APP程序将各自对应一个中断向量表，假设引导程序占用N+M Byte的FLASH空间。上电后，单片机从复位中断向量表处获取地址，并跳转执行复位中断服务函数，执行完毕后执行主函数，随后执行Bootloader中程序跳转的相关代码跳转至APP，即地址0x08000004+N+M处。进入主函数的步骤与Bootloader函数一致。当运行在主函数时，若有中断请求被响应，此时PC指针本应当指向位于地址0x08000004处的中断向量表，但由于程序预先通过“SCB->VTOR = 0x08000000 | ADDR_OFF;”这一语句，使得中断向量表偏移ADDR_OFF（N+M）地址，因此PC指针会跳转到0x08000004+N+M处所存放的中断向量表处，随后执行本应执行的中断服务函数，在跳出函数后再进入主函数运行。

![在这里插入图片描述](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/20190221125313717.png)

```c
void iapLoadApp(uint32_t appxAddr)
{
	iapfun jumptoapp;
	if( 0x20000000 == ( (*(vu32*)appxAddr) & 0x2FFE0000) )//检查appxaddr处存放的数据(栈顶地址0x2000****)是不是在RAM的地址范围内
	{ 
		jumptoapp = (iapfun)*(vu32*)(appxAddr + 4);//拷贝APP程序的复位中断函数地址，用户代码区第二个字为程序开始地址(复位地址)（强制跳转到函数地址处执行，函数指针的方式）
		MSR_MSP(*(vu32*)appxAddr);//初始化APP堆栈指针(用户代码区的第一个字用于存放栈顶地址)，重新分配RAM
		jumptoapp();//执行APP的复位中断函数，跳转到APP
	}
}	
```

# STM32内存模型

- 内存四区：代码区，全局区，堆区，栈区

1）Code：代码段，存放程序的代码部分；

2）RO-data：(Read Only )只读数据段，存放程序中定义的常量；

3）RW-data：(Read Write)读写数据段，存放初始化为非 0 值的全局变量；

4）ZI-data： (Zero Init) 数据段，存放未初始化的全局变量及初始化为 0 的变量；

```c
Total RO Size (Code + RO Data) 53668 ( 52.41kB)
Total RW Size (RW Data + ZI Data) 2728 ( 2.66kB)
Total ROM Size (Code + RO Data + RW Data) 53780 ( 52.52kB)
```

1）RO Size 包含了 Code 及 RO-data，表示程序占用 Flash 空间的大小；

2）RW Size 包含了 RW-data 及 ZI-data，表示运行时占用的 RAM 的大小；

3）ROM Size 包含了 Code、RO-data 以及 RW-data，表示烧写程序所占用的 Flash 空间的大小；

程序运行之前，需要有文件实体被烧录到 STM32 的 Flash 中，一般是 bin 或者 hex 文件，该被烧录文件称为可执行映像文件。如下图左边部分所示，是可执行映像文件烧录到 STM32 后的内存分布，它包含 RO 段和 RW 段两个部分：其中 RO 段中保存了 Code、RO-data 的数据，RW 段保存了 RW-data 的数据，由于 ZI-data 都是 0，所以未包含在映像文件中。

STM32 在上电启动之后默认从 Flash 启动，启动之后会将 RW 段中的 RW-data（初始化的全局变量）搬运到 RAM 中，但不会搬运 RO 段，即 CPU 的执行代码从 Flash 中读取，另外根据编译器给出的 ZI 地址和大小分配出 ZI 段，并将这块 RAM 区域清零。

![RT-Thread 内存分布](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/03Memory_distribution.png)

编译过程：.c中的变量不分配地址（.o中函数、变量地址为0），链接时依据link file规则分配

链接：将各个.o中的相同段进行合并（.text、.data、.bss），并找到所有符号的引用与定义的位置

| 地址   | 区域             | 内容                                                       | 存放位置 | 举例                                    |
| ------ | ---------------- | ---------------------------------------------------------- | -------- | --------------------------------------- |
| 0x0000 | .text 代码段     | 编译后的机器码                                             | Flash    | \#define ro_def 0x11111111UL            |
|        | .ROdata          | 只读常量                                                   | Flash    | const uint32_t ro_var = 0x22222222;     |
|        | .RWdata 已初始化 | 静态变量、全局变量，启动时从Flash读取已初始化数据搬运到RAM | RAM      | int global_var= 123;  static int c = 0; |
|        | .bss 未初始化    | 全局变量，启动时，自动初始化为0                            | RAM      | int global_var;                         |
|        | .heap  堆        | 动态内存分配，程序员手动开辟释放，向↓增长                  |          |                                         |
|        | ----------       |                                                            |          |                                         |
| 0xFFFF | .stack 栈        | 函数局部变量，由编译器开辟释放，向↑增长                    |          |                                         |

初始化过程：数据一开始都存储与ROM中，其中包含RO DATA（常量）、text（代码）、RW DATA（先存储于flash，上电后搬运到RAM）。RAM：加载来自于ROM 的 RW DATA，随后依据启动文件初始化ZI DATA为0

# GPIO

## I/O类型

| 分类     | 电平                                                         | 用途       | 备注                                                         |
| -------- | ------------------------------------------------------------ | ---------- | ------------------------------------------------------------ |
| 上拉输入 | 常态高电平（上拉电阻连接VCC）                                | IO读取     |                                                              |
| 下拉输入 | 常态低电平（下拉电阻连接GND）                                | IO读取     |                                                              |
| 推挽输出 | 可以输出高电平和低电平，都有较强驱动能力，IO输出0-接GND， IO输出1 -接VCC | 一般IO输出 | 驱动负载能力强                                               |
| 开漏输出 | 只能输出低电平，高电平没有驱动能力，需要外部上拉电阻才能真正输出高电平 | 线与功能   | 像IIC中，只要有一个给低电平，那么总线都会被拉低。实现线与功能 |

# 通信协议

## 对比

| 协议 | 通信速率                             | 优劣                                                         | 工作模式                                     | 模块数量                                           | 接口数量            | 时序图                                                       |
| ---- | ------------------------------------ | :----------------------------------------------------------- | -------------------------------------------- | -------------------------------------------------- | ------------------- | ------------------------------------------------------------ |
| UART | 115200 bit/s 约100 Kbit/s            | 优势：双线制，全双工  劣势：时序要求严格，速率低             | 全双工，异步（依据约定波特率采样）           | 一对一                                             | TX、RX              | 起始位低电平，数据位8 bit（每Byte数据先发送低位），停止位以及空闲高电平，一帧10 bit<img src="嵌入式笔记.assets/image-20221109181436534.png" alt="image-20221109181436534" style="zoom: 33%;" /><img src="嵌入式笔记.assets/v2-39dd6c1224d0e3fa0144e90519f4745d_720w.webp" alt="img" style="zoom:80%;" /> |
| 232  |                                      | 优势：规定了电气特性  劣势：传输距离15m，速率低              | 同UART                                       | 一对一                                             |                     |                                                              |
| 485  |                                      | 优势：规定了电气特性，可组网，传输距离远1500m  劣势：半双工  | 半双工                                       | 一对多                                             | A、B                | ![image-20221211170116471](嵌入式笔记.assets/image-20221211170116471.png) |
| IIC  | 100或400 Kbit/s                      | 优势：双线制，低成本，有应答。  劣势：通信速率低，半双工，通信距离短 | 半双工，同步（起始信号，应答信号，结束信号） | 多主多从（谁控制时钟线谁为主设备）（器件地址唯一） | SDA、SCLK           | 每Byte数据先发送高位，一帧9bit，SCLK（高电平读取，低电平发送）![img](嵌入式笔记.assets/20180514184751564.png)<img src="嵌入式笔记.assets/image-20221211112648861.png" alt="image-20221211112648861" style="zoom: 67%;" /> |
| SPI  | 10到150 Mbit/s                       | 优势：全双工高速，数据长度不限。   劣势：从机无应答信号，引脚较多，通信距离短 | 全双工，同步（拉低片选，依据时钟沿采样）     | 一主多从（一、多根互斥的CS片选）（二、菊花链）     | SCK、MOSI、MISO、CS | 每Byte数据先发送高位，帧长不限![在这里插入图片描述](嵌入式笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70.png)![img](嵌入式笔记.assets/v2-069df3709fb1a0c5486acbf620890313_720w.webp) |
| CAN  | bx CAN：1Mbit/s      CAN FD：8Mbit/s | 优势：差分电平通信距离长。  劣势：速率低带宽小               | 半双工                                       | 不分主从                                           | CANH、CANL          | ![在这里插入图片描述](嵌入式笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc0NjMyNQ==,size_16,color_FFFFFF,t_70#pic_center.png)![image-20221211172121365](嵌入式笔记.assets/image-20221211172121365.png) |



## UART

空闲时间总线高电平，起始位1bit拉低，数据位8bit，停止位1bit拉高

流控

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230608133657320.png" alt="image-20230608133657320" style="zoom: 50%;" />

作用：当通信双方处理速度不一致时

接收方：通过RTS告知对方自己正在处理，占用时拉高（发送方等待），空闲时拉低（发送方发送）

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230608134131700.png" alt="image-20230608134131700" style="zoom:67%;" />

发送方：判断CTS信号，拉低时发送

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230608134204871.png" alt="image-20230608134204871" style="zoom:67%;" />



## TTL

供电范围在0~5V；>2.7V是高电平；<0.5V是低电平



## RS232

±15V

负电平表示逻辑"1"，正电平表示逻辑"0"，通过提高电压差的方式抗干扰

- 负电平范围为-3V至-15V
- 正电平范围为+3V至+15V

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230725215502450.png" alt="image-20230725215502450" style="zoom:50%;" />



## RS485

±6V

通过差分信号抗干扰，当A线高于B线时，表示逻辑"1"；当B线高于A线时，表示逻辑"0"。

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230725215739796.png" alt="image-20230725215739796" style="zoom:50%;" />



## IIC

- 总线空闲时，SCLK与SDA均为高电平
- 连接到总线上的任一器件，输出低电平，都将使总线的信号变低。
- 连接总线的器件输出级必须是集电极或漏极开路，以形成线“与”功能。
- 每个具有IIC接口的设备都有一个唯一的地址，也叫做设备地址，通讯时需要进行寻址。

![image-20230608100609847](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230608100609847.png)

开始信号：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。（SDA先拉低）
结束信号：SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据。（SCL先拉高）
应答信号：每当主机发送完1Byte，总要等待从机给出1bit的应答信号，以确认从机是否成功接收到了数据（主机SCL拉高，读取从机SDA的低电平为应答）

采样点：**稳态电平采样**

**当SCL=1高电平时进行数据采样，数据线SDA不允许有电平跳变，否则视为开始与停止信号**

![image-20221211134858814](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20221211134858814.png)

通信过程：

![image-20221211134845009](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20221211134845009.png)

1. 主机发送起始信号
2. 主机发送1Byte（从机地址+后续数据传送方向）每个器件具有唯一地址7bit，数据方向：0写1读
3. 从机发送应答信号1bit
4. 发送方与接收方相继发送1Byte+应答信号
5. 主机发送结束信号

写时序

![image-20230608104611870](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230608104611870.png)

读时序

![image-20230608104640190](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230608104640190.png)

冲突检测与仲裁：（发送方监测，发送电平与SDA电平不符时关闭输出）

- 一种简单的预防冲突机制是：设备在发送数据之前，需要进行冲突检测，检测的依据就是检查SDA的电平状态：只要检测到SDA为低电平，那就是表示总线处于被占用的状态，那么，为了避免发生冲突，当前设备必须等待一段时间以后再次去检测SDA的电平状态，如果总线变成“空闲”的了（即SDA为高电平），那么该设备才能进行通信。

- 这里有一个关键点就是：如何保证连接到I2C总线上的多个的设备，只要存在一个设备占用了总线，其他设备无论如何也不能使总线变为空闲呢？上文说的集电极开路结构就能达到这个要求。
- 每个设备的SDA输出的值，不完全相同，但是，只要有一个为“0”，其结果就是“0”，这就是**线与**，其可以保证SDA线上的信号，要么稳定为“0”（至少一个设备输出为0），要么稳定为“1”（全部设备输出都为1）。



- IIC从机地址配置方式

1. 内部固定地址：某些 I2C 从机设备具有内部固定的从机地址，无法进行配置或更改。在这种情况下，从机地址是设备制造商预定义的。

2. 硬件引脚配置：一些 I2C 从机设备具有专用引脚或引脚配置选项，用于设置从机地址。通过使用跳线帽、电阻、芯片的引脚配置等方式，用户可以将特定的引脚配置为高电平或低电平，从而设置从机地址。

3. 寄存器配置：一些 I2C 从机设备允许使用特殊的寄存器配置来设置从机地址。这通常通过主机和从机之间的特殊序列和命令来实现。

- IIC地址交换

运行过程中，如果新的IIC设备接入，主机和从机如何交换地址？

1. 主机发送广播地址（遍历所有预定义的地址进行扫描），等待应答
2. 从机监听到自己地址后进行应答

- IIC最大设备数量

I2C 协议使用地址来选择特定的从设备进行通信。每个从设备都有一个唯一的 7 位或 10 位地址。

在 I2C 协议中，最多可以有 128 个 7 位地址设备和 1024 个 10 位地址设备。但实际可连接的设备数量受制于总线负载和电气特性等因素。



## SPI

四种模式：

时钟极性(CPOL)定义了时钟空闲状态电平：

- CPOL=0，表示当SCLK=0时处于空闲态，所以有效状态就是SCLK处于高电平时
- CPOL=1，表示当SCLK=1时处于空闲态，所以有效状态就是SCLK处于低电平时

时钟相位(CPHA)定义数据的采集时间。

- CPHA=0，在时钟的第一个跳变沿（上升沿或下降沿）进行数据采样。，在第2个边沿发送数据
- CPHA=1，在时钟的第二个跳变沿（上升沿或下降沿）进行数据采样。，在第1个边沿发送数据

|  mode  | CPOL | CPHA | 描述                                                         |
| :----: | :--: | :--: | ------------------------------------------------------------ |
| mode 0 |  0   |  0   | <img src="嵌入式笔记.assets/988790-20200311120321586-1644899478.png" alt="img" style="zoom:67%;" /> |
| mode 1 |  0   |  1   | <img src="嵌入式笔记.assets/988790-20200311120250511-621966252.png" alt="img" style="zoom:67%;" /> |
| mode 2 |  1   |  0   | <img src="嵌入式笔记.assets/988790-20200311121435779-1051725621.png" alt="img" style="zoom: 80%;" /> |
| mode 3 |  1   |  1   | <img src="嵌入式笔记.assets/988790-20200311121424628-840109130.png" alt="img" style="zoom: 80%;" /> |

一主多从时的连接：（多CS）（菊花链）

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/v2-90fa89c6af8665282dd058768841801f_720w.webp" alt="img" style="zoom: 67%;" /><img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/v2-b15a465be84b4cdde9272cf3ce7eeee6_720w.webp" alt="img" style="zoom:67%;" />

软件SPI与硬件SPI：

- 软件SPI用GPIO口的电平变化模拟SPI通信时序，移植性好，占用CPU资源，速度慢
- 硬件SPI用HAL库封装的**HAL_SPI_Transmit**即可，占用CPU资源少，速度快，但对PCB走线有要求

采样点：**边沿采样**

SPI接口的一个缺点：没有指定的流控制，没有应答机制确认是否接收到数据。

![image-20230715144916989](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230715144916989.png)



## CAN

物理层：两条线差分电平0~5 V，CAN H电压高于CAN L为显性电平（逻辑0），采用CAN收发器将TX RX电平转换为差分，各设备采用ID号区分

![image-20230608160858116](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230608160858116.png)

标准： bx CAN 2.0 b： 1 Mbps，每帧8 Byte带CRC

​			CAN FD： 8 Mbps，每帧64 Byte

时序：保证总线上各设备时钟不同步情况下，通信是同步的，将1 Bit分为三段再分为多个Tq

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20221129101750717.png" alt="image-20221129101750717" style="zoom: 33%;" />

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20221129102857765.png" alt="image-20221129102857765" style="zoom:33%;" />

数据帧：存在连续5个以上相同位，帧中需要插入一个相反的位（stuff bit）

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20221129144752322.png" alt="image-20221129144752322" style="zoom: 67%;" />

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20221129102041789.png" alt="image-20221129102041789" style="zoom: 80%;" />

仲裁：CAN 为半双工，不可同时收发，依据ID号中的0的数量进行仲裁

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20221129102403615.png" alt="image-20221129102403615" style="zoom: 33%;" />

STM32 CAN结构：

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20221129102808659.png" alt="image-20221129102808659" style="zoom:33%;" />

过滤器：实际使用中采用列表模式，资源紧张时采用掩码模式

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20221129120519771.png" alt="image-20221129120519771" style="zoom:33%;" />

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20221129120644982.png" alt="image-20221129120644982" style="zoom:33%;" />

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20221129120723292.png" alt="image-20221129120723292" style="zoom:33%;" />

​															此处有误，应是`0x00` `0x1FF`与`0x100`掩码，按位与为1的位需要匹配，为0的位不滤除

双接收中断FIFO： 

每当收到一个报文，CAN就将这个报文先与FIFO_0关联的过滤器比较，如果被匹配，就将此报文放入FIFO_0中。如果不匹配，再将报文与FIFO_1关联的过滤器比较，如果被匹配，该报文就放入FIFO_1中。如果还是不匹配，此报文就被丢弃

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20221129120918262.png" alt="image-20221129120918262" style="zoom:33%;" />



CAN最多可以挂载110个节点，依据总线负载率<70%

# 异常和中断

- 中断初始化

  1. 设置中断源，让某个外设可以产生中断；

  2. 设置中断控制器，使能/屏蔽某个外设的中断通道，设置中断优先级等；

  3. 使能CPU中断总开关


  CPU在运行正常的程序

  产生中断，比如用户按下了按键 —> 中断控制器 —> CPU

  **CPU每执行完一条指令（指令有多个时钟周期，取指、译码、执行等）都会检查是否有异常/中断产生**

  发现有异常/中断产生，开始处理：

  1. 保存现场（PC、LR、MSP、通用寄存器、FPU压栈）

  2. 分辨异常/中断，调用对应的异常/中断处理函数

  3. 恢复现场（PC与出栈）

- 相同点：都是CPU对系统发生的某个事情做出的一种反应

- 区别：中断由外因引起，异常由CPU本身原因引起

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTk2Mjg1,size_16,color_FFFFFF,t_70.png" alt="img" style="zoom:67%;" />

## STM32中断

- 定义：正在执行某事件时，被某事件打断，造成任务切换
- 分类：内核异常、外部中断
- 嵌套向量中断控制器NVIC：多个优先级中断到来后的处理顺序

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTk2Mjg1,size_16,color_FFFFFF,t_70-16709870095783.png" alt="img" style="zoom:67%;" />

- 处理流程：CPU收到(interrupt request，IRQ)后，通过上下文切换保存当前工作状态，跳转至中断处理函数执行（中断向量表），完成后再出栈执行原有程序



# 定时器

## STM32定时器

- 系统滴答定时器`SysTick`（并非外设，CM3内核）
- 看门狗定时器`WatchDog`
  - 定时喂狗，否则触发系统复位
  - IWDG独立看门狗：采用独立时钟，监视硬件错误
  - WWDG窗口看门狗：采用系统时钟，监视软件错误（必须在规定时间窗口刷新）（防止跑飞后跳过某些代码段）（进入WWDG中断时，可以保存复位前的数据）
- 基本定时器`TIM6,TIM7`
- 通用定时器`TIM2,TIM3,TIM4,TIM5`（输出比较、输入捕获、PWM、单脉冲）
- 高级定时器`TIM1,TIM8`（死区控制）
- 基本定时：预分频、重装载寄存器
- PWM：预分频、重装载、比较寄存器

# ADC

## 采样原理

逐次逼近转换过程和用天平称物重非常相似。天平称重物过程是，从最重的砝码开始试放，与被称物体进行比较，若物体重于砝码，则该砝码保留，否则移去。再加上第二个次重砝码，由物体的重量是否大于砝码的重量决定第二个砝码是留下还是移去。照此一直加到最小一个砝码为止。将所有留下的砝码重量相加，就得此物体的重量。仿照这一思路，逐次比较型A/D转换器，就是将输入模拟信号与不同的参考电压作多次比较，使转换所得的数字量在数值上逐次逼近输入模拟量对应值。

![img](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/25999089-20433dbc3f0a1fe5.png)

## STM32 ADC

STM32F1 ADC，精度为12位，每个ADC最多有16个外部通道，各通道的A/D转换可以单次、连续扫描或间断执行，ADC转换的结果（6-12位）可以左对齐或右对齐储存在16位数据寄存器中。ADC的输入时钟不得超过14MHz，其时钟频率由PCLK2分频产生。

一个ADC的不同通道读取的值在共用的DR寄存器中，进行下一个通道采集前需要将数据取走否则丢失

注入通道：可以在规则通道转换时，强行插入转换

参考电压：3.3V

采集精度与位数：最大测量电压/2^采样位数，例如3.3V / 2^12，采样逐次逼近

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20221209182245687.png" alt="image-20221209182245687" style="zoom: 50%;" />

精度 

实际值和采样值的偏差



分辨率

10cm长的尺子，最小刻度是1mm，分辨率是1mm

由采样位数决定。一个12位的ADC可以将输入电压转换为4096个离散的数值（2^12 = 4096）

# DMA

## STM32 DMA

- 当外部设备（如硬盘、显卡、网络适配器等）需要与主存储器进行数据交换时，需要通过中央处理器（CPU）作为中介来完成数据传输操作。然而，在大量数据传输的情况下，这样的方式会造成CPU过多地参与数据传输，降低了整体性能。

  CPU将外设数据搬运到内存的顺序：

  1. 外设设置状态寄存器置位
  2. CPU读取外设数据寄存器到CPU通用寄存器
  3. CPU将通用寄存器数据写入内存

  CPU不介入情况下，将数据在外设与内存中传递

  ![image-20230706174634517](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230706174634517.png)

  DMA配置：数据宽度（u8 u16 u32），数据量(sizeof)，数据地址

  循环模式：单轮传输结束后，重置传输计数器，重置传输地址为初始值，再次开始新一轮循环

  双缓冲区：一个缓冲区传输完成中断触发后，缓存地址乒乓交换，同时触发回调函数

  DMA会节约总线资源吗（不能，他只是节约了CPU）

  

  DMA配置

  1. 配置DMA控制器：设置DMA通道、数据传输方向（外设到存储器或存储器到外设）、传输模式（单次传输、循环传输等）、数据宽度、传输计数等参数
  2. 分配内存：如果是外设到存储器的数据传输，需要分配一块足够大小的缓冲区
  3. 配置DMA通道：将外设和DMA通道连接起来，通常需要配置外设的DMA请求触发方式和DMA通道的优先级等参数。
  4. 触发DMA传输：启动数据的传输。DMA控制器将自动执行数据的传输，而不需要CPU的干预。

  

  **实际应用**

  - 分析性能瓶颈在哪，是数据频率还是数据量过大
  - 数据频率：双DMA BUF
  - 数据量：单个大 DMA BUF