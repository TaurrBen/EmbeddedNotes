

[TOC]

# C基础知识

## ==标识符==

``` c
extern	声明变量是在其他文件正声明
typedef	用以给数据类型取别名
auto	声明自动变量
static	声明静态变量int声明整型变量或函数
const	声明只读变量
volatile	说明变量在程序执行中可被隐含地改变long声明长整型变量或函数
register	声明寄存器变量
```
- extern

  - Q&A: **extern "C"**的作用
    - 是告诉**C++编译器**用C规则编译指定的代码（除函数重载外，**extern “C”**不影响C++其他特性）
  
  
    - ```c
      //区分
      char *filename = "aaa";
      extern char *filename;
      
      char filename[] = "aaa";
      extern char filename[];
      ```
  


- typedef

  - 常规用法

    - ```c
      typedef char* PCHAR1;
      typedef struct Books
      {
         char  title[50];
         char  author[50];
         char  subject[100];
         int   book_id;
      }Book;
      typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型
      ```


  - Q&A: **typedef**和**#define**

    - **#define** 是 C 指令，用于为各种数据类型定义别名，也能为数值定义别名

    - **typedef** 仅限于为类型定义符号名称

    - **typedef** 是由编译器执行处理的，**#define** 语句是由预编译器进行处理的。

    - **typedef作用域**

      - 如果放在所有函数之外，它的作用域就是从**它定义开始直到文件尾**
      - 如果放在某个函数内，它的作用域就是从**它定义开始直到该函数结尾**

    - **#define作用域**

      - 不管是在某个函数内，还是在所有函数之外，作用域都是从定义开始直到整个文件结尾（不管是typedef还是define，其作用域都不会扩展到别的文件，即使是同一个程序的不同文件，也不能互相使用）

    - ```c
      typedef char* PCHAR1;
      #define PCHAR2 char *
      
      PCHAR1 c1,c2;//c1和c2都是指针
      PCHAR2 c3,c4;//c3是指针，c4不是指针
      ```


- auto
  - 动态存储，如果不赋初值，将是一个不确定的值。


- static

  - 修饰全局变量
    - **静态全局变量**（存放在数据段(.data段/.bss段)）仅对当前文件可见，其他文件不可访问，其他文件可定义相同变量名，两者互不影响

    - 修饰局部变量
      - **静态局部变量**（存放在数据段(.data段/.bss段)）初始化为0，运行一开始开辟内存，内存放在全局，增加了变量的存活时间与函数的堆栈区不在同一个区域，因此函数运行完毕后静态局部变量不会被释放。
      - **静态局部变量**只赋一次初值。下次使用静态局部变量的时候直接使用上次保存下来的值而不会重新赋值。
    
    
    - 修饰函数
      - **静态函数**只能在声明它的文件中可见，其他文件不能引用该函数，其他文件函数名可相同，是对函数本身的一种保护机制。
    
  - 头文件中定义静态变量
    - 含该头文件的源文件会有命名相同但实际不同的静态变量


- const

  - 修饰普通变量

    ```c
    const int a = 100;int const a = 100;//常量、定义同时必须初始化
    const int MaxNum1 = getNum();  //运行时初始化
    const int MaxNum2 = n;         //运行时初始化
    const int MaxNum3 = 80;        //编译时初始化
    ```
  
  
    - 修饰指针
  
      ```c
      //const 离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据。
      const int *p;//修饰指针指向的数据只读-----常用来作为形参指针
      int const *p;//修饰指针指向的数据只读
      int * const p;//修饰指针变量
      const int * const p;int const * const p;//两者
      const char **       // 是一个指向指针的指针，那个指针又指向一个字符串常量。   
      char **             // 也是一个指向指针的指针，那个指针又指向一个字符串变量。
      ```
  
      - 不能将const char *类型的数据赋值给char *类型的变量。但反过来是可以的，编译器允许将char *类型的数据赋值给const char *类型的变量。
  
  
    - 全局常量（静态存储区）、局部常量（栈）、const修饰的字符串常量（常量存储区）
  
  
    - Q&A:const + volatile 为只读状态寄存器
  


- volatile

  - 防止被优化（意想不到的改变）优化器在用到这个变量时必须每次都小心地重新读取这个变量的值,而不是使用保存在寄存器里的备份。

  - volatile是对编译器的约束，可以控制每次从RAM读取到通用寄存器，但无法控制从RAM到通用寄存器的过程（从RAM到寄存器要经过cache）。若两次被volatile修饰的读取指令过快，即使RAM中的值改变了，但由于读取过快没有更新cache，那么实际上搬运到通用寄存器的值来自于cache，此类情况下需要禁用cache。
  
  - 编译器优化是针对于LDR命令的，从内存中读取数据到寄存器时不允许优化这一过程，而None-cache保护的是对内存数据的访问（volatile无法控制LDR命令执行后是否刷新cache）
  
    ```c
    //注意要把常量转换成无符号整形指针的数据类型，一般还要加 volatile 防止被优化
    volatile unsigned int *p = (volatile unsigned int *)0x000051EF;
    printf("p = 0x%p\n", p);
    ```
  
  
    - 中断服务程序中修改的供其它程序检测的变量需要加volatile，也可以使用关键区保护；
  
  
    - 多任务环境下各任务间共享的标志应该加volatile，也可以关闭系统调度；
  
  
    - 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义。
  
  
    - 理解为直接存取原始内存地址
  
  
    - Q&A:当一个中服务子程序修该一个指向一个buffer的指针时，buffer应加volatile
  


- register
  - 会优先存储在CPU寄存器中（但不一定会存储在寄存器中，因为寄存器数量是有限的），而且该变量不能使用取地址符(&)


```c
void	声明函数无返回值或无参数，声明无类型指针float声明浮点型变量或函数
signed	声明有符号类型变量或函数
unsigned	声明无符号类型变量或函数
char	声明字符型变量或函数
short	声明短整型变量或函数
int		声明整型变量或函数
long    声明长整型变量或函数
float	声明单精度变量或函数
double	声明双精度变量或函数
struct	声明结构体变量或函数
union	声明共用数据类型
enum	声明枚举类型
```

- 数据类型

  - float和double的存储
    - 1 + 8 + 23、1 + 11 + 52

  - Q&A:判断两个浮点数相等（和0做比较）
    - float 6~7位有效数字，double 15~16位有效数字


- struct
  - 略


- union
  - 共用体占用的内存应足够存储共用体中最大的成员，共用体赋值会导致覆盖。


- enum

  - 第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。

    ```c
    enum season {spring, summer=3, autumn, winter}; //0 3 4 5
    ```


  - 内存大小一般小于1个int类型数


``` c
for	一种循环语句do循环语句的循环体
do 
while	循环语句的循环条件
if	条件语句
else	条件语句否定分支（与 if 连用）
switch	用于开关语句
case	开关语句分支
goto	无条件跳转语句
break	结束当前循环，跳出当前循环
continue	结束当前循环，开始下一轮循环
default	开关语句中的其他分支
```

- if-else

  - 赋值后判断

    ```c
    if((filedesc = open(argv[i],0)) < 0)
        error();
    ```
  
  
    - if-else匹配问题
  
      ```c
      if (x == 0)
          if(y == 0) error();
      else{
          z = x + y;
          f(&z);
      }
      //等价于
      if (x == 0){
          if(y == 0) error();
          else{
              z = x + y;
              f(&z);
          }
      }
      ```
  
  
  
    - if else的优缺点
  
      - if else的优点：if else能应用于更多的场所以if else比较灵活。
  
      - if else的缺点：if else必须遍历所以的可能值。
  


- switch

  - break匹配输出问题

  - **switch case的优缺点**
    - switch case的优点：
      1. 当分支较多时，用switch的效率是很高的。因为switch是确定了选择值之后直接跳转到那个特定的分支.
    - switch case的缺点：
      1. switch...case占用较多的代码空间，因为它要生成跳表，特别是当case常量分布范围很大但实际有效值又比较少的情况，switch...case的空间利用率将变得很低。
      2. switch...case只能处理字符或者数字类型的变量的情况。


- while

  ```c
  int k = 10;
  while(--k >= 0)
  ```

## ==基本数据类型==

linux系统下的字节数，windows64位下的long(int)和unsigned  long(int)均为4个字节。

|      DataType       |   16    |   32    |   64    |
| :-----------------: | :-----: | :-----: | :-----: |
|        char         | 1个字节 | 1个字节 | 1个字节 |
|    short（int）     | 2个字节 | 2个字节 | 2个字节 |
|         int         | 2个字节 | 4个字节 | 4个字节 |
|    unsigned int     | 2个字节 | 4个字节 | 4个字节 |
|        float        | 4个字节 | 4个字节 | 4个字节 |
|       double        | 8个字节 | 8个字节 | 8个字节 |
|      long(int)      | 4个字节 | 4个字节 | 8个字节 |
|   long long(int)    | 8个字节 | 8个字节 | 8个字节 |
| unsigned  long(int) | 4个字节 | 4个字节 | 8个字节 |
|        指针         | 2个字节 | 4个字节 | 8个字节 |
|        数组         |         |         |         |
|       结构体        |         |         |         |
|     结构体-位域     |         |         |         |
|       联合体        |         |         |         |
|         类          |         |         |         |

- 047和47不同：047是八进制数、47是十进制数
- ascii码：
  - \n是换行，英文是New line，换行就是把滚筒卷一格，不改变水平位置。
  - \r是回车，英文是Carriage return，回车就是把水平位置复位，不卷动滚筒。
  - Enter = 回车+换行(\r\n)   注:\r\n连用时,  不能调换顺序
    - Unix换行：\n(0x0A)
    - MAC回车：\r(0x0D)

    - WIN回车换行：\r\n(0x0D,0x0A)


## ==作用域==

- 代码块作用域：{}

- 文件作用域：文件内部

- 原型作用域：函数原型中声明的参数名
- 函数作用域

## ==操作符与表达式==

- 左值和右值

- 类型转换
  - 隐式类型转换
  - 类型强转
  
- 优先级和求值顺序和表达式的值
  
  - 如果一个表达式中的两个操作数具有相同的优先级，那么它们的结合律（associativity）决定它们的组合方式是从左到右或是从右到左。
  
    <img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/v2-47e3ccc5d262631d2d3f44918791f47d_720w.webp"/>
  
  - 单目运算符、双目运算符（算数运算符、移位运算符、关系运算符、逻辑运算符、赋值运算符）、条件运算符、逗号运算符
    
    - sizeof:即是关键字也是运算符
    
    - 后缀++：先返回一份拷贝，再增加操作数的值，表达式的值是原指针的一份拷贝
    
    - ++前缀：先增加操作数的值，再返回这个结果，表达式的值是增值后指针的一份拷贝
    
    - 逗号表达式：从左到右逐个计算，表达式的值为最后一个表达式的值
    
    - 位操作：
    
      ```c
      #define GetBit(x , bit)   (((x) & (1 << (bit)) >> (bit))  // 获取将x的第y位（0或1）先左移再右移
      #define SetBit(x , bit)   ((x) |=  (1 << (bit))  // 将X的第Y位置1
      #define ClrBit(x , bit)   ((x) &= ~(1 << (bit))  // 将X的第Y位清0
      ```
    
  
- 贪心法
  - C编译器规则：每一个符号应该包含尽可能多的字符。

- 短路原则

## ==数组与指针==

- 类型转换符（）

  - 知道如何声明一个给定类型的变量，只需要把声明中的变量名和末尾的分号去掉，再整体括号起来就是该类型的类型转换符

  ```c
  float (*fp)();//(float (*)()) 为指向返回值为浮点类型的函数的指针
  (*fp)();//等价于fp() 即调用了fp指向的函数
  
  //eg1.调用首地址为0的子例程
  (*(void (*)())0)();
  //或者
  typedef void (*funcptr)();
  (*(funcptr)0)();
  
  //eg2.signal函数 接受被捕获signal的整数值，然后用回调函数调用他
  void (*signal())(int);//调用signal，并对其函数指针类型的返回值解引用，然后传递一个整型参数调用解引用所得到的函数，最后返回void类型；
  void (*signal(int, void (*)(int)))(int);
  //或者
  typedef void (*HANDLER)(int);
  HANDLER signal(int HANDLER);
  ```

- 访问内存中某地址数据

  ```c
  // 读取
  int result=*(int *)0x123456;  // 方法1
  int *ptr=const(int *)0x123456;  // 方法2
  int result=*ptr;
  // 修改
  *(int * const)(0x56a3) = 0x3344;  // 方法1
  int * const ptr = (int *)0x56a3;  // 方法2
  *ptr = 0x3344;
  ```
  
- 数组理解：只有一维数组、要确定数组大小、以及获得指向该数组下标为0的元素的指针

  - 指针常量（数组解释）、常量指针

  - ```C
    int day[30];
    //day是一个数组，大小为30，day指向该数组下标为0的元素的指针即&day[0]（除被用作sizeof参数外）
    //*day是指向该数组下标为0的元素的引用day[0]  ---->*(day + i) = day[i]
    //故将数组作为参数无意义，char s[] 等价于 char*s、char *argv[]等价于char **argv
    //区分extern char *hello;和extern char hello[];
    int calendar[12][31];
    //calendar是一个数组，拥有12个数组类型的元素，每个元素拥有31个int类型的元素
    //calendar转换为指向数组的指针
    //----->*(*(calendar + month) + day) = calendar[month][day]
    //二级指针遍历二维数组
    int (* monthp)[31];
    for(monthp = calendar; monthp < &calendar[12]; monthp++){
        int *dayp;
        for(dayp = *monthp;dayp < &(*monthp)[31]; dayp++){
            *dayp = 0;
    	}
    }
    ```

- Q&A：指针和数组的效率

  - 指针

- 指针运算：++、–、+、-、关系运算符

- 字符串常量

  strlen只计算字符串所包括的字符数目，sizeof计算包括作为结束标志的空字符

- 空指针

  空指针非空字符串、空指针不能被解引用（除用来判断if(p ==  (char *) 0)）

- 间接访问运算符/解引用指针

  - 解引用表示访问指针变量所存放的内存地址、并查看里面的值
    - 即左值是指针变量所存放的内存地址，右值是左值地址上的值


- > <img src="c_assets/指针.png" style="zoom:50%;" /> 

- 二级指针、数组指针、指针数组、字符串指针、函数指针、指针函数、函数指针数组、结构体指针、结构体指针数组、
  - <img src="c_assets/各类型指针声明.png" style="zoom:%;" />
  - 二级指针：二级指针不能指向二维数组
  - 函数指针：
  - 双指针数组：
  
    ```c
    int ** a[3][4];//(*(a+i)+j)或者a[i][j]访问元素
    ```

## ==函数==

### 函数调用过程

- 保存寄存器中的函数返回地址（caller的下一条语句的执行地址）、栈顶地址到栈上
- 栈顶指针偏移（由高地址向低地址移动）
- 入参压栈
  - 调用函数时，入栈顺序为参数从右往左，从而取参数时从左往右
  - 右边的参数先入栈，存放在R0-R3中，多余4个的参数存放在任务栈中
  - 返回值在R0寄存器

- 局部变量压栈
- 执行函数代码
- 退出时恢复caller的函数返回地址、栈顶指针地址到寄存器中

### 函数参数

- 一维数组形参：等同于指针
- 二维数组形参：只能数组指针来接受其二维数组地址
- 回调函数：函数指针来接受回调函数
  - 回调机制允许下层软件层调用上层软件层定义的函数。
  - 事件回调、寄存器中的多个回调
  - 函数指针可能会阻止编译器执行的一些优化（函数内联）

### 可变参数列表

- stdarg宏
  - va_list 、va_start、va_arg、va_end

## ==字符串==

### 字符串函数

```c
#include <string.h>
char *p = "hello";
//输出字符串
puts(p);
//输入字符串
char str[128] = "\0";   //字符数组初始化\0
scanf("%s", str);
gets(str); //
getchar(s);
//复制字符串 表示把src所指向的字符串中以src地址开始的前n个字节复制到dest所指的数组中，并返回被赋值后的dest。
char *strncpy(char *dest, const char *src, int n);
//拼接字符串 把src所指向的字符串（包括“\0”）复制到dest所指向的==字符串后面==（删除`*dest`原来末尾的“\0”）。要保证`*dest`足够长，以容纳被复制进来的`*src`。`*src`中原有的字符不变。返回指向dest的指针。
char *strcat(char *dest, const char *src);
//比较字符串 若str1=str2，则返回零；若str1<str2，则返回负数；若str1>str2，则返回正数
int strcmp(const char *s1,const char *s2);
int strncmp (const char * str1, const char * str2, size_t n );
//void memset(首地址, 值, sizeof(地址总大小));
void *memset(void *s, int c, unsigned long n);
```

- 字符数组和字符串

  - ```c
    char str[] = "hello";   //字符串数组，可以修改数组内容
    char *pchar = "hello";  //字符串指针变量，此时的"hello"为字符串常量，不能再通过指针来修改其内容
    ```

## ==结构体==

### 结构体定义初始化

- 指定初始化（顺序随意）

  ```c
  static struct usb_driver usb_storage_driver = {   
      .owner = THIS_MODULE,      
      .name = \"usb-storage\",      
      .probe = storage_probe,      
      .disconnect = storage_disconnect,      
      .id_table = storage_usb_ids, }; 
  
  struct A a;
  //错误赋值
  a = {1,2};
  //正确赋值
  struct A a = {1,2};
  ```

- 访问方式

  - 通过结构体变量名访问，用点（成员选择（对象））运算符

    - 通过结构体指针间接访问，先取内容为结构体，然后用点（成员选择（对象））运算符

      - ```c
        (*p).idata;  //点的优先级比*高，需要加括号
        ```

  - 通过结构体指针间接访问，用->（成员选择（指针））运算符

### 结构体数组初始化

- ```c
  struct student
  {
      int mum;
      char name[20];
      char sex;
      int age;
      float score;
      char addr[30];
  }stu[3] = {{10101,"Li Lin", 'M', 18, 87.5, "103 Beijing Road"},
              {10101,"Li Lin", 'M', 18, 87.5, "103 Beijing Road"},
              {10101,"Li Lin", 'M', 18, 87.5, "103 Beijing Road"}};
  struct student stu[3];
  ```

### 结构体之位域

- 一个位域必须存储在同一个字节中，不能跨两个字节。

- 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。

- ```c
  struct bs  
  {  
      unsigned a:4  
      unsigned b:5 /*从下一单元开始存放*/  
      unsigned c:4  
  }
  struct k  
  {  
      int a:1  
      int :2 /*无位域名，该2位不能使用*/  
      int b:3  
      int c:2  
  };
  ```

### 结构体的深浅拷贝

- 当结构体中有指针成员的时候容易出现浅拷贝与深拷贝问题

- 浅拷贝就是，两个结构体变量的指针成员指向同一块堆栈空间，在各个结构体变量释放的时候会出现多次释放统一堆栈空间
- 深拷贝就是，让两个结构体变量的指针成员分别指向不同的堆区空间，只是空间内容拷贝一份，这样在各个结构体变量释放的时候就不会出现多次释放同一段堆区空间的问题

## ==通用库、标准输入输出==

| 标准文件 | 文件指针 | 设备     |
| :------- | :------- | :------- |
| 标准输入 | stdin    | 键盘     |
| 标准输出 | stdout   | 屏幕     |
| 标准错误 | stderr   | 您的屏幕 |

### 缓冲区

- 输入缓冲区和输出缓冲区

- 全缓存：==缓冲区被填满以后才进行真正的输入输出操作==

  - 将数据写入文件后，打开文件并不能立即看到内容，只有清空缓冲区，或者关闭文件，或者关闭程序后，才能在文件中看到内容。

- 行缓冲：==在输入或者输出的过程中遇到换行符时，才执行真正的输入输出操作==

  - 键盘（scanf、getchar、gets）和显示器（Linux的printf、puts、putchar）

  - ```c
    printf("C语言中文网");
    sleep(5);  //程序暂停5秒钟
    printf("http://c.biancheng.net\n");//两个printf一起输出
    ```

- 不带缓存

  - Windows的getche和getch、Windows的printf和puts和putchar、perror

- 刷新缓冲区

  - 不管是行缓冲还是全缓冲，缓冲区满时会自动刷新；
  - 行缓冲遇到换行符`\n`时会刷新；
  - 关闭文件时会刷新缓冲区；
  - 程序关闭时一般也会刷新缓冲区，这个是由标准库来保障的；
  - 使用特定的函数也可以手动刷新缓冲区，例如 fflush()。

### 常用函数

```c
int printf(const char *format, ...);//printf()函数中，从右往左计算，输出的字符数量
int puts(const char *s);//函数把字符串s和一个尾随的换行符写入到stdout
putchar('abc'); // 输出字符'c' ，多个字符时输出最后一个字符，返回同样的字符
int scanf(const char *format, ...);//空格、回车也是字符
	scanf("%[^\n]%*c", str);//碰见了回车就退出，然后把缓冲区里面的内容按字符串格式输入str中，回车依然留在缓冲区
	scanf("%*[^0-9]");//读取非数字，但是不向任何地方输入
int getchar(void);//getchar返回一个整数
char *gets(char *s);//从stdin读取一行到s所指向的缓冲区，直到一个终止符或 EOF，可能会导致缓冲区溢出
fgets();//代替gets
void qsort(void *, size_t, size_t, int (comp*)(const void *, const void *));
```

### 格式化输出

- %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数

## ==文件IO==



## ==段错误==

### 段错误产生原因

- 访问不存在的内存地址
  - 对空指针或者未初始化指针进行解引用

- 访问只读的内存地址
- 访问系统保护的内存地址
  - 数组越界访问

- 栈溢出

### 调试方法

- 查找指针变量是否未初始化、数组是否存在越界访问

- ```
  $ gcc -g -o test test.c
  $ gdb ./test
  ```

## ==C面向对象==

### 多态

- ```c
  struct ShapeVtbl;
  // Shape 的属性
  typedef struct {
      struct ShapeVtbl const *vptr;//虚指针
      int16_t x; 
      int16_t y; 
  } Shape;
  // Shape 的虚表
  struct ShapeVtbl {
      uint32_t (*area)(Shape const * const me);
      void (*draw)(Shape const * const me);
  };
  //构造函数中的虚表
  // Shape 类的虚表
  static struct ShapeVtbl const vtbl = 
  { 
      &Shape_area_,
      &Shape_draw_
  };
  ```



## ==内存分配问题==

### 野指针

- 悬挂指针：指针指向的内存被删除
- 野指针：==指针变量未初始化，指针free后未置空，超出作用范围==；指针被创建缺省值是随机的。

### strcpy与memcpy的区别

- strcpy 是依据 "\0" 作为结束判断的，如果 dest 的空间不够，则会引起 buffer overflow。
- memcpy用来在内存中复制数据，由于字符串是以"\0"结尾的，所以对于在数据中包含"\0"的数据只能用memcpy。（通常非字符串的数据比如结构体都会用memcpy来实现数据拷贝）
- strncpy和memcpy很相似，只不过它在一个终止的空字符处停止。当n>strlen(src)时，给dest不够数的空间里填充"\0“；当n<=strlen(src)时，dest是没有结束符"\0“的。这里隐藏了一个事实，就是dest指向的内存一定会被写n个字符。使用strncpy时，确保s2的最后一个字符是"\0”。
- strcpy只是复制字符串，但不限制复制的数量，很容易造成缓冲==溢出==。strncpy要安全一些。strncpy能够选择一段字符输出，strcpy则不能。

### malloc和free的实现原理

### 内存泄漏

- 什么是内存泄漏
  - 若申请的内存一直未释放或无法释放，最后会导致堆可用的空间越来越少，严重的会导致程序崩溃。
- 避免内存泄漏的方法
  - 代码检视
  - 代码静态扫描工具
  - 工具检测，如valgrind

### 大小端存储

- 大小端存储转换

  ```c
  #define swap_endian_u16(A) (((A) & 0xFF00 >> 8) | ((A) & 0x00FF << 8))
  ```

- 字节序和位序
  - 0x12345678  大端存储高到低（78、56、34、12）（00110000）
  - 0x12345678  小端存储高到低（12、34、56、78）（00001100）

### 内存对齐

- 什么是内存对齐
  - 要求数据的首地址的值是某个数k（通常它为4或8）的倍数

- 为什么要内存对齐
  - 加快cpu访问内存的速度

- 内存存取粒度
  - 处理器存取单元

- 对齐系数和对齐单位

  - gcc中默认#pragma pack(4)、linux下默认#pragma pack(4)

  - 对齐单位
    - #pragma pack(n)和结构体中最长数据类型长度中较小值

- 内存对齐规则

  - **数据成员对齐规则**：结构（struct）（或联合（union））的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的==子成员大小==（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始（比如int在32位机为4字节，则要从4的整数倍地址开始存储）。

  - **结构体作为成员**：如果一个结构体里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储（struct a 里存有struct b，b里有char，int，double等元素，那么b应该从8的整数倍开始存储）。

  - **收尾工作**：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐。

- 结构体之位域的对齐

  - 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止

  - 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍

- C++中的类

  - 类中没有成员从称空类，sizeof(空类)=1，类中成员函数不占空间，除非是虚函数

  - 若类中包含成员，则仅算非静态成员对齐后的空间，同结构体对齐

  - 若类中包含虚函数，则sizeof(数据成员)的和+sizeof(虚表指针，为4)

  - 对于继承父类的子类，为父类成员+子类成员对齐后所占空间

  - 若子类和父类都有虚函数，父类成员+子类成员+sizeof(虚表指针，为4)

  - 若是虚继承的子类，父类成员+子类成员+指向父类的指针(4)

  - 若是虚继承有虚函数的子类，父类成员（+虚表指针4）+子类成员（+虚表指针4）+指向父类的指针（4）

### 内存分区

- 5分区（4分区将BSS段和数据段合并为静态存储区）

  - BSS段( bss(Block Started by Symbol) segment )(.bss)：静态内存分配

    - 未初始化的全局变量和静态变量（初始化为0的呢？）
    - 在运行时分配并被有效地清零（==隐式初始化为0==）
    - BSS节在应用程序的二进制映象文件中并不存在,即==不占用磁盘空间==而只在运行的时候占用内存空间

    - 数据段(data segment)：静态内存分配

      - 已经初始化的全局变量和静态变量（.data）

      - 包括只读数据段（.rodata）和读写数据段

        1.只读数据段：字符串常量

    - 代码段(code segment/text segment)(.text)
      - 程序执行代码

    - 堆(heap)：动态内存分配
      - 进程调用malloc等函数分配内存，利用free等函数释放内存
      - 堆内存运行时分配的，堆区是由下往上增长，分配随机值一般用memset（）清0

  - 栈 (stack)：动态内存分配
    - 存放函数的参数以及局部变量，但不包括static声明的局部变量，故未初始化的局部变量是随机值
      - 函数被调用时,其参数也会被压入发起调用的进程栈；调用结束后,函数的返回值也会被存放回栈
      - 先进先出，保存/恢复调用现场
      - 栈内存编译阶段完成，栈区空间是由上往下增长

### 内存布局（4G虚拟地址空间 32为操作系统）

<img src="c_assets/内存布局.png" style="zoom:67%;" />

<img src="c_assets/变量内存分配位置.png" style="zoom:120%;" />

### 堆栈问题

- 堆栈溢出（栈）

  - 是什么：当一个程序在执行过程中使用了太多的堆栈空间，导致堆栈内存溢出，无法继续正常执行。
  - 原因：递归调用、大规模的局部变量
  - 怎么办：
    - 优化递归算法：确保递归函数有正确的终止条件，避免无限递归。可以考虑使用==迭代代替递归==，或者采用==尾递归优化==等技术减少堆栈空间的使用。
    - 减少局部变量的使用：尽量避免在函数中定义过多的局部变量，可以考虑将一些变量声明为全局变量或静态变量，或者使用动态内存分配（如堆内存）来存储大规模的数据。
    - 增加堆栈空间的限制：在某些编程语言中，可以通过配置编译器或运行时环境来增加堆栈的大小限制，以便为程序提供更多的堆栈空间。
    - 使用动态内存分配：对于需要大量内存的操作，可以考虑使用动态内存分配（如malloc或new）来分配堆内存，而不是使用堆栈空间。
    - 代码审查和测试：进行代码审查和全面的测试，以发现潜在的堆栈溢出问题。尽早发现并修复这些问题可以避免在运行时出现堆栈溢出错误。

- 堆和栈区别

  - 申请方式：stack：系统分配与回收（栈内存分配运算内置于处理器的指令集）；heap：程序员申请与释放
  - 存储位置与方向：stack：高地址—》低地址；heap：低地址—》高地址
  - 碎片问题：stack无碎片FIFO；heap存在内外碎片
  - 存放内容：stack：函数返回地址、局部变量的值；heap：用户定义
  - 栈的动态分配主要是malloc函数实现的，由编译器自动释放；堆只有动态分配用new实现，由程序员手动释放

- 栈指针（SP）

  - 用于指示程序在执行过程中的当前堆栈位置。它指向堆栈顶部或下一个可用的堆栈位置。
  - 作用：函数调用、局部变量的分配和释放、堆栈帧（函数的参数、局部变量和返回地址等信息）的管理

- 如何检查调试堆栈问题

  - 使用日志和调试输出：通过在关键位置插入日志语句或调试输出语句，记录堆栈状态和相关信息，以便跟踪问题。可以使用串口输出、调试端口或其他适配的输出方式来查看日志。
  - 堆栈监视器：某些嵌入式系统提供硬件或软件堆栈监视器。这些监视器可以实时监测堆栈的状态，包括栈指针的变化和堆栈溢出。具体实现和使用方法会根据嵌入式系统的硬件和工具链而有所不同。
  - 断言（Assertions）：在关键位置使用断言来检查堆栈状态是否符合预期。断言是一种在代码中插入的检查语句，如果条件不满足，则会触发断言失败，进而中断程序执行，以便进行调试。
  - 动态内存分析工具：使用适用于嵌入式系统的动态内存分析工具可以帮助检测和调试堆栈问题，例如MemCheck、Valgrind等。这些工具可以跟踪内存分配和释放操作，检测内存泄漏和堆栈溢出等问题。
  - 静态代码分析工具：使用静态代码分析工具可以检查代码中的潜在堆栈问题，例如递归调用没有终止条件、局部变量超出作用域等。常用的静态代码分析工具包括Lint工具。
  - 使用硬件调试器：连接硬件调试器可以提供更详细和准确的堆栈信息。通过硬件调试器，可以实时查看和修改栈指针的值，观察堆栈帧的状态，并跟踪函数调用和返回的路径。

- 中断和异常的堆栈

  - 在计算机系统中，中断和异常处理是处理与正常程序执行流程不同的情况的机制。在这些情况下，系统需要保存当前正在执行的程序的上下文信息，以便在处理完中断或异常后能够恢复到正常执行流程。堆栈在中断和异常处理中起着重要的作用，用于保存和恢复程序的上下文信息。

    当中断或异常发生时，处理器会自动保存当前正在执行的程序的上下文信息到堆栈中。这包括程序计数器（保存当前指令的地址）、寄存器状态和其他相关信息。然后，处理器会跳转到中断或异常处理程序，该程序会执行与中断或异常相关的操作。

    在处理程序执行期间，堆栈用于保存处理程序的局部变量和临时数据。这些数据可以通过堆栈指针进行访问。当处理程序完成时，处理器从堆栈中恢复先前保存的上下文信息，包括程序计数器和寄存器状态，以便继续执行被中断或异常中断的程序。 使用堆栈进行中断和异常处理时，需要注意以下几点：

    1. `堆栈大小`：为了确保堆栈能够容纳所有需要保存的上下文信息和处理程序的局部变量，堆栈的大小应该足够大。否则，可能会发生堆栈溢出的情况，导致数据丢失或系统崩溃。
    2. `堆栈指针管理`：堆栈指针是用于访问堆栈数据的重要指针。在中断和异常处理期间，必须正确地管理堆栈指针，确保保存和恢复上下文信息的正确性。
    3. `中断和异常处理的嵌套`：当系统出现多个中断或异常同时发生时，可能会发生处理程序的嵌套执行。在这种情况下，必须正确地保存和恢复多个处理程序的上下文信息，以避免数据丢失或处理错误。

- 多线程堆栈管理

  - 在多线程环境中，每个线程都有自己的堆栈，用于保存线程的局部变量和执行状态。下面是一些常用的方法和参考链接，可以帮助管理和调试每个线程的堆栈：
    1. `调试器`：使用调试器是一种常见的方法，可以管理和调试每个线程的堆栈。调试器可以让你暂停线程的执行并检查其堆栈，查看局部变量、函数调用链和执行路径。常用的调试器包括GDB（GNU Debugger）和LLDB（LLVM Debugger）等。你可以通过调试器的命令和功能来管理和分析每个线程的堆栈。
    2. `栈跟踪`：栈跟踪是一种技术，用于获取当前线程的堆栈信息。通过在代码中插入栈跟踪代码或使用栈跟踪函数，可以获取每个线程的堆栈信息并输出到日志或终端。这样可以帮助你了解每个线程的执行路径和调用关系。具体的栈跟踪方法和函数库可能会依赖于所使用的编程语言和开发环境。
    3. `性能分析工具`：性能分析工具通常提供了监测和分析多线程应用程序的功能，包括堆栈分析。这些工具可以帮助你收集线程的执行信息和堆栈信息，并提供可视化界面来分析每个线程的堆栈情况。一些常用的性能分析工具包括perf、Intel VTune、Java VisualVM等。

- 任务堆栈和中断堆栈

  - 任务堆栈（Task Stack）是用于管理嵌入式系统中任务（或线程）执行的堆栈。每个任务都有自己的任务堆栈，用于保存任务的局部变量、函数调用信息和执行状态。任务堆栈的大小通常在任务创建时指定，并根据任务的需求进行调整。任务堆栈的主要作用是支持任务之间的切换和保存任务的执行上下文，以便能够在任务切换时恢复到上一个任务的执行状态。

  - 中断堆栈（Interrupt Stack）是用于管理处理器中断和异常处理的堆栈。当中断或异常发生时，处理器会自动切换到中断堆栈，并保存当前执行的程序的上下文信息。中断堆栈用于保存中断或异常处理程序的局部变量、函数调用信息和执行状态。与任务堆栈不同，中断堆栈的大小通常是固定的，并且由硬件或操作系统预先定义。中断堆栈的目的是支持中断处理程序的执行，并确保在处理完中断或异常后能够返回到原来的程序执行位置。

    区别：

  - 任务堆栈用于管理任务（或线程）的执行，而中断堆栈用于处理中断和异常。 

  - 任务堆栈由操作系统或任务调度器进行管理，而中断堆栈由处理器和中断控制器进行管理。

  - 任务堆栈的大小可变，而中断堆栈的大小通常是固定的。

- 堆栈回溯（Stack Trace）

  - 记录了函数调用链的顺序，包括每个函数的调用关系和返回地址。
  - 符号表和map文件

- 栈保护机制和防止栈溢出攻击

  - `栈保护位（Stack Canary）`：栈保护位是一种常见的栈保护机制。在函数的栈帧中，将一个特殊的随机值（称为栈保护位或栈哨兵）放置在返回地址之前。函数执行完毕时，会检查栈保护位是否被修改。如果栈保护位的值被修改，说明栈溢出发生了，程序将终止执行。
  - `栈溢出检测技术`：一些编程语言和编译器提供了栈溢出检测技术。例如，使用栈溢出检测函数（如canary函数）或编译选项（如-fstack-protector）可以在运行时检测栈溢出，并采取相应的防护措施。
  - `内存布局随机化（ASLR）`：ASLR 是一种安全机制，通过随机化程序的内存布局来增加攻击者的难度。通过随机化堆栈的地址，攻击者无法准确预测栈的位置和布局，从而降低栈溢出攻击的成功率。
  - `安全编程实践`：编写安全的代码是防止栈溢出攻击的关键。使用安全的字符串处理函数，避免缓冲区溢出，限制用户输入的长度等都是重要的安全编程实践。

## ==编译器==

- 编译器将内存和名字关联起来

- 三个编译过程的作用
  - 前端：分析源码文件生成程序的中间表示(Intermediate representation, IR),该过程主要包括预处理、词法分析、语法分析和语义分析
  - 中端：也被称为优化器，对前端生成的IR进行优化以提高程序的性能及质量
  - 后端：主要处理CPU架构相关的优化及生成目标机器代码

- 编译过程：><img src="c_assets/编译过程.png"/>

  ![image-20221130195604365](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20221130195604365.png)

  1. 预处理：展开宏定义，文件嵌套、删除注释
  2. 编译：转换为汇编（检查语法不检查逻辑）
  3. 汇编：转换为机器码
  4. 链接：符号表查找与填充地址，库的链接，将汇编文件中函数的临时0地址进行填充，将每个符号定义与一个内存位置相关联起来

### 预编译

- 宏(#define、#unde、#ifdef、#ifndef、#elif、#else、\#endif)

  - 不能忽视宏中的空格

  - 宏不是函数，自增需要注意

  - 断言宏

    - ```c
      #define assert(e)\
      		((void)((e)||_assert_error(__FILE__,__LINE__)))
      //那么它先向 stderr 打印一条出错信息,然后通过调用 abort 来终止程序运行。
      //使用 assert 的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。
      ```

  - #ifndef
    - 与#prama once 不同的是其不仅是“物理上”的同一个文件，而且是内容相同的文件。

  - #pragma

    - #pragma once

      - 预编译会保留所有的#pragma编译器指令，后续编译过程需要使用它们。

      - 避免同一个头文件被包含多次（“物理上”的同一个文件）

      - 避免了名字冲突、但兼容性不好

    - #pragma pack(n) n = 1,2,4,8,16

  - defined函数
    - defined （宏名）被定义返回1，未被定义返回0

  - ==宏函数==没有普通函数参数压栈、跳转、返回等的开销，可以提高程序的效率。

- 条件编译

  ```c
  #if 整型常量表达式1
    程序段1
  #elif 整型常量表达式2
    程序段2
  #else
    程序段3
  #endif
  ```

- 头文件

  ```c
  #include <stdio.h> //编译器会到系统路径下查找头文件
  #include "stdio.h" //编译器会先在当前目录下查找头文件，如果没有找到，再到系统路径下查找
  ```

- 特殊符号
  - LINE标识将被解释为当前行号（十进制数），FILE则被解释为当前被编译的C源程序的名称

### 编译

- 进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码。

### 汇编（获得可重定位文件）

- **汇编过程调用对汇编代码进行处理，生成处理器能识别的指令，保存在后缀为.o的目标文件中。**由于每一个汇编语句几乎都对应一条处理器指令，因此，**汇编相对于编译过程比较简单，通过调用Binutils中的汇编器as根据汇编指令和处理器指令的对照表一一翻译即可。**
- 可重定位文件：其中包含有适合于其它目标文件链接来创建一个可执行的或者共享的目标文件的代码和数据。

- 共享的目标文件：存放了适合于在两种上下文里链接的代码和数据。第一种是链接程序可把它与其它可重定位文件及共享的目标文件一起处理来创建另一个 目标文件；第二种是动态链接程序将它与另一个可执行文件及其它的共享目标文件结合到一起，创建一个进程映象。

- 可执行文件：包含了一个可以被操作系统创建一个进程来执行之的文件。汇编程序生成的实际上是第一种类型的目标文件。对于后两种还需要其他的一些处理方能得到，这个就是链接程序的工作了。

### 链接

- 符号解析（Symbol resolution全局符号解析和局部符号解析）、符号重定位（Symbol relocation转为绝对地址）、合并和组织代码（Code merging and organization）、解决库依赖（Library dependency resolution）、符号表生成（Symbol table generation）

- 静态链接将所有的函数和库代码合并到一个可执行文件中，执行速度快，但可执行文件较大；而动态链接在运行时加载所需的函数和库代码，可执行文件较小，但可能需要额外的加载时间依赖系统存在相应的动态链接库文件。选择使用哪种方式取决于项目的需求和考虑的因素。

- ==静态链接==

  - 静态链接是指在编译阶段直接把静态库加入到可执行文件中去，这样可执行文件会比较大。如果所使用的静态库发生更新改变，程序必须重新编译。

  - 符号解析（把目标文件中符号的定义和引用联系起来）和重定位（把符号定义和内存地址对应起来然后修改所有对符号的引用）。

  - 优点：
    - 执行速度快，为所有代码已经被编译和链接在一起，无需运行时动态加载额外的库文件。
    - 可执行文件独立，可以在没有安装相应库文件的系统上运行。

  - 缺点：
    - 可执行文件较，因为所有依赖的函数和库代码都被静态链接到可执行文件中。
    - 更新和替换依赖的函数和库代码需要重新编译和链接整个程序。

- ==动态链接（优先动态库）==

  - 发现这个函数名是一个动态链接符号，可执行程序就**不对这个符号进行重定位**，而把这个过程留到装载时再进行。
  - 动态链接则是指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去。
  - 链接结果是一个可执行文件和一个或多个动态链接库，可执行文件只包含必要的启动代码和符号引用。
  - 优点：
    - 可执行文件较小，因为只包含必要的启动代码和符号引用。
    - 动态链接库可以在多个可文件之间共享，节省内存空间。
    - 更新和替换依赖的函数和库代码只需要替换对应的动态链接库。
  - 缺点：
    - 相对于静态链接，运行时需要额外的时间加载和解析动态链接库。 -中必须存在相应的动态链接库文件，否则程序无法运行。

- 程序装入

  - 一、绝对装入（编译时确定绝对地址）

    - 再另一台内存不同的电脑上可能无法运行

    

  - 二、静态重定位（保存相对地址）（读取时转换）

    - 编译、链接后存放为逻辑地址，保存的都是相对于0地址的相对值
    - 地址空间必须连续且读入内存时，对所有逻辑地址进行运算，转换为物理地址（读入时）

    

  - 三、动态重定位（保存相对地址）（运行时转换）

    - 程序读入内存后，并不直接计算物理地址，实际执行时才进行转换，将逻辑地址转换为物理地址（调用时）

    <img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230701214310764.png" alt="image-20230701214310764" style="zoom: 50%;" />

    <img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230701214850436.png" alt="image-20230701214850436" style="zoom:67%;" />


### ELF文件分析

- ELF文件的段
  - .text：已编译程序的指令代码段。
  - .rodata：ro代表read only，即只读数据（譬如常数const）。
  - .data：已初始化的C程序全局变量和静态局部变量。
  - .bss：未初始化的C程序全局变量和静态局部变量。
  - .debug：调试符号表，调试器用此段的信息帮助调试。
  - <img src="c_assets/ELF文件格式.jpeg" style="zoom:67%;" />
- 

### GCC工具链

- 交叉编译：在一个平台（主机平台）上生成另一个平台（目标平台）上的可执行代码
- 交叉编译器：执行交叉编译的编译工具链

```
$ gcc -E hello.c -o hello.i // 将源文件hello.c文件预处理生成hello.i

$ gcc -S hello.i -o hello.s // 将预处理生成的hello.i文件编译生成汇编程序hello.s

$ gcc -c hello.s -o hello.o // 将编译生成的hello.s文件汇编生成目标文件hello.o
$ as -c hello.s -o hello.o //使用Binutils中的as将hello.s文件汇编生成目标文件

$ gcc hello.c -o hello
$ gcc -static hello.c -o hello

//查看其各个section的信息如下
$ readelf -S hello
//反汇编
$ objdump -D hello
$ gcc -o hello -g hello.c //要加上-g选项
$ objdump -S hello

Binutils
- addr2line：用来将程序地址转换成其所对应的程序源文件及所对应的代码行，也可以得到所对应的函数。该工具将帮助调试器在调试的过程中定位对应的源代码位置。

- as：主要用于汇编，有关汇编的详细介绍请参见后文。

- ld：主要用于链接，有关链接的详细介绍请参见后文。

- ar：主要用于创建静态库。为了便于初学者理解，在此介绍动态库与静态库的概念：
		如果要将多个.o目标文件生成一个库文件，则存在两种类型的库，一种是静态库，另一种是动态库。
		在windows中静态库是以 .lib 为后缀的文件，共享库是以 .dll 为后缀的文件。在linux中静态库是以.a为后缀的文件，共享库是以.so为后缀的文件。
		静态库和动态库的不同点在于代码被载入的时刻不同。静态库的代码在编译过程中已经被载入可执行程序，因此体积较大。共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。在Linux系统中，可以用ldd命令查看一个可执行程序依赖的共享库。
		如果一个系统中存在多个需要同时运行的程序且这些程序之间存在共享库，那么采用动态库的形式将更节省内存。

- ldd：可以用于查看一个可执行程序依赖的共享库。

- objcopy：将一种对象文件翻译成另一种格式，譬如将.bin转换成.elf、或者将.elf转换成.bin等。

- objdump：主要的作用是反汇编。有关反汇编的详细介绍，请参见后文。

- readelf：显示有关ELF文件的信息，请参见后文了解更多信息。

- size：列出可执行文件每个部分的尺寸和总尺寸，代码段、数据段、总大小等，请参见后文了解使用size的具体使用实例。

C运行库
```

- 编译器选项和优化策略
  - `-Os`：此选项将编译器优化为最小化代码大小。它会执行一系列优化，包括消除未使用的代码、常量折叠和传播、简化表达式等。
  - `-O2`或`-O3`：这些选项表示编译器使用更高级别的优化来提高性能和代码大小。较高级别的优化可能会增加编译时间，但通常会提供更好的性能。
  - `-ffunction-sections -fdata-sections`：这些选项将代码和数据分离成小节，以便进行进一步的优化和链接时的死代码消除。这可以减小最终的可执行文件大小。
  - `-flto`：此选项启用链接时优化（Link Time Optimization），它在链接过程中对整个程序进行优化。这可以提供更高级别的优化和更好的性能。
  - `-finline-functions`：此选项启用函数内联优化，将函数调用替换为函数体的副本。这减少了函数调用的开销，提高了性能。
  - `-fomit-frame-pointer`：此选项告诉编译器省略函数调用时的Frame Pointer，从而减少了堆栈操作和代码大小。
  - `-march`和`-mtune`：这些选项用于指定目标处理器的体系结构和微体系结构，以便编译器能够生成针对特定处理器优化的代码。
  - `-falign-functions`和`-falign-loops`：这些选项控制函数和循环的对齐方式，以提高内存访问的效率。
  - `-fno-unroll-loops`：此选项禁用循环展开优化，适用于循环次数较多或代码大小有限的情况。

### make、makefile、CMake、qmake

- make是软件开发过程中非常常用的一个工具，它读取工程中的`makefile`文件以自动构建软件。
- CMake本身并不具备构建功能，而是通过读取`CMakeList.txt`生成其它构建系统的构建文件

### GDB调试（lldb用于macos）

```
help: 获取gdb命令帮助
help <command>: 获取特定gdb命令的帮助
run: 运行到下个断点或程序结束
step: 单步（逐语句）调试，会进入到函数内部执行
next: 单步（逐语句）调试，但不会进入到函数内部执行
finish: 结束当前函数或循环
continue: 执行到下个断点或程序结束
up <N>: 往栈顶移动N帧，N默认为1
down <N>: 往栈顶移动N帧，N默认为1
list: 打印当前点附近的代码
print <name>: 打印名为name的变量值
print *<name>: 打印name指针指向的值
print/x <name>: 以16进制打印name的值
print <name>@<n>: 打印以name为起始地址的n个值
break <name>: 在函数name处设置断点
break <num>: 在行num处设置断点
disable 1: 去使能断点1
enable 1: 使能断点1
delete 1: 删除断点1
delete: 删除所有断点
condition 1 <expr>: 断点1的停止条件为表达式expr为true
condition 1: 删除断点1的所有条件
info break: 显示所有的断点信息
backtrace: 查看栈信息
display <name>: 始终显示变量name的值
undisplay <name>: 取消跟踪name的值
watch <expr>: 监视expr的值，一旦有变化就暂停程序
```

- 调试原理
  - 使用系统调用`ptrace`(process trace)去观察和控制其它进程的执行、检查和修改其它进程的内存和寄存器。
  - gdb断点（breakpoint）功能是在指定位置插入断点指令（INT），当被调试的程序执行到断点位置时，产生`SIGTRAP`信号并转由gdb处理。
  - 多进程调试：fork之后，跟踪父进程；若要跟踪子进程，attch pid或者设置set follow-fork-mode
  - 多线程调试：thread <threadno>命令用于在调试的进程间切换、info threads命令用于查询所有已存在的线程、thread apply <threadno> <all> args命令用于对指定的一条线程或多条指令应用指令
  - core（core dump file）文件：终止时，将此时进程空间的内容及有关进程的状态的其它信息写入一个磁盘文件；需要配置使能core dump或者在gdb中使用指令generate-core-file

## ==可移植性==

- 字符是有符号整数还是无符号整数
  - 使用(unsigned char)c，因为这个类型转换为无符号整数时无需先转换int，而是直接转换

- 移位运算符的移位实现、移位操作的位数是否可以取负数

