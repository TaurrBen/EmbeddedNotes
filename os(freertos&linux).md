# 操作系统

- 嵌入式固件（Firmware）是指嵌入在嵌入式系统中的软件程序或代码，用于控制和管理硬件设备的操作。它是一种针对特定硬件平台和应用需求编写的低级软件，通常以二进制形式存储在非易失性存储器（如闪存或EEPROM）中。嵌入式固件通常包括引导程序（bootloader）、驱动程序、实时操作系统（RTOS）、应用程序等，它们共同协同工作以实现嵌入式系统的预期功能。
  - 硬实时系统对任务的截止期限有严格要求，必须在规定的时间内完成，而软实时系统的任务截止期限相对宽松，任务的延迟可以被容忍。根据具体的应用需求和实时性要求，选择合适的实时系统类型非常重要。
  - `并行处理(Parallel computing)`：并行处理是指同时执行多个任务或操作，利用多个处理单元（如多个处理器核心）并行地完成任务。在并行处理中，多个任务可以同时进行，每个任务由不同的处理单元处理，从而加快整体系统的处理速度。并行处理通常需要专门的硬件支持，如多核处理器或并行计算机系统。
 - `并发处理(Concurrency)`：并发处理是指同时处理多个任务或操作，通过时间片轮转或其他调度算法，使得多个任务交替执行。在并发处理中，每个任务在时间上交替执行，虽然不能同时进行，但通过快速切换和调度，给用户一种同时执行的感觉。

 区别：

  1. `并行处理`：在嵌入式系统中，并行处理常用于需要高性能和高吞吐量的应用场景，例如图像和视频处理、信号处理和实时控制系统等。通过利用多个处理核心同时执行不同的任务，可以提高系统的实时性和响应能力。

  2. `并发处理`：在嵌入式系统中，由于资源有限或任务优先级不同，常常需要采用并发处理的方式。例如，实时操作系统（RTOS）使用任务调度器来管理和调度多个任务，每个任务按照一定的时间片轮转方式执行。这样可以实现多个任务的同时进行，提高系统的资源利用率和任务的响应速度。

## FreeRTOS

- `时间管理`：RTOS通过提供任务调度和事件管理功能，确保系统中的任务按照优先级和时间要求进行合理调度。它可以分配和管理任务的处理时间，确保关键任务能够按时完成，从而满足实时性要求。
  - `中断处理`：嵌入式系统通常依赖于硬件中断来处理外部事件。RTOS能够有效管理中断请求，及时响应和处理来自外部设备的中断，并且可以根据优先级来处理多个中断请求。
  - `任务管理`：RTOS允许将系统功能划分为多个独立的任务，每个任务都有自己的优先级和执行时间要求。RTOS负责调度和管理这些任务，确保它们以正确的顺序和时间执行，从而实现系统的并发和实时性。
  - `资源管理`：嵌入式系统中的资源（如处理器、内存、输入/输出等）通常是有限的。RTOS提供资源管理功能，确保不同任务之间对共享资源的访问进行合理分配和调度，以防止冲突和资源争用。
  - `通信和同步`：RTOS提供了各种通信机制和同步原语，用于任务之间的信息交换和协调。这些机制可以包括消息队列、信号量、事件标志等，用于实现任务之间的通信和同步操作。
  - `可靠性和容错性`：RTOS通常设计为高可靠性和容错性，以应对嵌入式系统中的错误和异常情况。它提供了错误处理机制、任务监控和故障恢复等功能，以确保系统能够在异常情况下正确运行并保持稳定性。

### ==创建任务函数==

- 在堆中通过pvPortMalloc分配内存给TCB
- 在创建任务时，可以选择动态创建或静态创建，静态的任务栈在任务结束后无法被回收，动态的可以

```c
/* 函数原型 */
portBASE_TYPE xTaskCreate( pdTASK_CODE pvTaskCode,
                            const signed portCHAR * const pcName,
                            unsigned portSHORT usStackDepth,
                            void *pvParameters,
                            unsigned portBASE_TYPE uxPriority,
                            xTaskHandle *pxCreatedTask );
/* 函数示例 */
static TaskHandle_t myTaskHandler = NULL;

xTaskCreate(ATaskFunction, "myTask", 512, NULL, configMAX_PRIORITIES - 4, &myTaskHandler);
```

### ==删除任务函数==

```c
/* 函数原型 */
void vTaskDelete( xTaskHandle pxTaskToDelete );
```

### ==任务优先级==

- 低优先级号表示任务的优先级低，优先级号0表示最低优先级。有效的优先级号范围从0到`(configMAX_PRIORITES – 1)`。

| 函数                       | 说明                      |
| -------------------------- | ------------------------- |
| vTaskPrioritySet()         | 可以动态的更改任务优先级  |
| uxTaskPriorityGet()        | 获取任务优先级            |
| uxTaskPriorityGetFromISR() | 在ISR函数中获取任务优先级 |

- 优先级反转
  - 有优先级为A、B和C三个任务，优先级A>B>C，任务A，B处于挂起状态，等待某一事件发生，任务C正在运行，此时任务C开始使用某一共享资源S。在使用中，任务A等待事件到来，任务A转为就绪态，因为它比任务C优先级高，所以立即执行。当任务A要使用共享资源S时，由于其正在被任务C使用，因此任务A被挂起，任务C开始运行。如果此时任务B等待事件到来，则任务B转为就绪态。由于任务B优先级比任务C高，因此任务B开始运行，直到其运行完毕，任务C才开始运行。直到任务C释放共享资源S后，任务A才得以执行。在这种情况下，优先级发生了翻转，任务B先于任务A运行。
  - freertos 使用优先级继承来==解决优先级反转==问题：当任务A 申请共享资源S 时， 如果S正在被任务C 使用，通过比较任务C 与自身的优先级，如发现任务C 的优先级小于自身的优先级， 则将任务C的优先级提升到自身的优先级， 任务C 释放资源S 后，再恢复任务C 的原优先级。
- RTOS==优先级的分配==原则
  - 依据任务对响应的敏感性、执行时长（RTOS抢占式，会导致饥饿）
  - 串口接收中断等任务优先级最高
  - 电机PID计算以及控制需要固定控制周期，优先级较高
  - 看门狗，按键处理中等、
  - 最低的APP层的心跳和信息显示任务

### ==延时函数==

```c
void vTaskDelay( portTickType xTicksToDelay );//xTicksToDelay 表示延时多少个tick,该函数会把task切出到阻塞态
```

### ==精确延时函数==

```c
//调用此函数的任务解除阻塞的时间是绝对时刻，比起vTaskDelay()延时时间更精确
void vTaskDelayUntil( portTickType * pxPreviousWakeTime, portTickType xTimeIncrement );
```

### ==空闲任务==

### ==队列==

- 

```c
//创建队列
xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength,unsigned portBASE_TYPE uxItemSize );
//写入到队列首
portBASE_TYPE xQueueSendToFront( xQueueHandle xQueue,const void * pvItemToQueue,portTickType xTicksToWait );
//写入到队列尾
portBASE_TYPE xQueueSendToBack( xQueueHandle xQueue,const void * pvItemToQueue,portTickType xTicksToWait );
//发送队列
```

### ==系统运行过程==

### ==协程--croutine.c==

### ==任务管理、系统调度==

- 任务调度

  - 系统时钟判断最高优先级任务进行调度

  - 当前任务主动执行taskYIELD()或portYIELD_FROM_ISR()让出CPU使用权

  - FreeRTOS中任务调度器触发了 `SVC` 中断来启动第一个任务，之后的工作都靠 `PendSV` 和 `SysTick` 中断触发来实现

    `SVC`是系统服务调用，由 `SVC` 指令触发调用。在 [FreeRTOS](https://so.csdn.net/so/search?q=FreeRTOS&spm=1001.2101.3001.7020) 中用来在任务调度中开启第一个任务。触发指令：svc 0

    - `SVC`中断就是软中断，给用户提供一个访问硬件的接口
    - `PendSV`中断相对`SVC`来说，是可以被延迟执行的，用于任务切换

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述" style="zoom: 67%;" />

- 任务的优先级和调度
  - 优先级分配：为每个实时任务分配适当的优先级，根据任务的紧急程度和重要性确定其执行顺序。通常，优先级较高的任务会在优先级较低的任务之前执行。
    - 调度算法：选择合适的调度算法来决定任务的执行顺序。常用的==调度算法==包括先来先服务（FCFS）、最短作业优先（SJF）、优先级调度、循环调度（Round-Robin）等。根据系统需求和任务特点选择合适的调度算法。
    - 中断处理：对于具有实时要求的任务，使用中断来响应外部事件或触发条件。中断处理可以立即打断当前任务的执行，执行紧急的任务，然后返回原来的任务继续执行。
    - 资源管理和互斥：确保共享资源的安全访问和避免竞争条件。使用互斥锁、信号量、事件标志等机制来实现对共享资源的互斥访问和同步。
    - 实时任务设计：在设计实时任务时，要考虑任务的执行时间、截止期限、依赖关系等因素。确保任务能够在规定的截止期限内完成，并满足实时性要求。
    - 性能分析和调试工具：使用性能分析工具和调试工具来监测和分析实时任务的执行情况，识别潜在的性能问题和调度延迟，并进行优化和调试。

### ==内存管理==

- 内存管理算法：heap_1~5中除了heap_3分配在堆上，其余算法在bss段开辟静态空间进行管理

| 类别   | 优点                 | 缺点                             |
| ------ | -------------------- | -------------------------------- |
| heap_1 | 时间确定             | 只分配，不回收                   |
| heap_2 | 最佳匹配             | 回收但不合并、时间不确定         |
| heap_3 | 使用标准malloc、free | 代码量大、线程不安全、时间不确定 |
| heap_4 | 最佳匹配、合并相邻   | 时间不确定                       |
| heap_5 | 支持多段不连续RAM    | 时间不确定                       |

1. **heap_1**：只分配不回收，不合并空闲区块

2. **heap_2**：使用最佳拟合算法分配；回收，但不合并，有碎片

3. **heap_3**：使用标准库malloc()和free()函数、heap的大小由链接器配置定义（启动文件定义）

4. **heap_4**：使用first fit算法来分配内存、合并相邻的空闲内存块

![在这里插入图片描述](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/856ee0739f2c46798c2c3dc3c76ff4c8.png)

5. **heap_5**：在heap_4的基础上，可以从多个独立的内存空间分配内存

- FreeRTOS的内存位于.bss段，并非heap（启动文件中的堆空间大小）

  使用`pvPortMalloc`函数申请内存时，也是从这个系统堆（实际为bss段）中申请的

  ```c
  #define configTOTAL_HEAP_SIZE                        ( ( size_t ) ( 100 * 1024 )   // 申请100KB内存用于RTOS系统堆内存
  ```

  在map文件中可以看到FreeRTOS使用一个静态数组作为HEAP，以我使用的`heap_4.c`内存管理策略来说，它定义在`heap_4.c`这个文件里面。因为这个HEAP来自于静态数组，所以它存在于数据段(具体为.bss段)，并不是我一开始认为的FreeRTOS所使用的HEAP来自于系统的堆。

  ```c
  .bss                  zero     0x2021'7d1c  0x1'9000  heap_4.o [35]  // 实际位于.bss段
  
  Entry                       Address      Size  Type      Object
  -----                       -------      ----  ----      ------
  ucHeap                  0x2021'7d1c  0x1'9000  Data  Lc  heap_4.o [35]  // 起始地址与大小
  ```


- RTOS为何不用malloc和free

  - 实现复杂，占用空间较多
  - 并非线程安全操作
  - 每次调用执行时间不确定
  - 内存碎片化
  - 不同编译器适配复杂
  - 难以调试

- ==内存池==

  - 是一种用于管理和分配内存的技术。它被用于**解决频繁地申请和释放内存带来的性能问题**。
  - 在传统的内存管理中，当需要使用内存时，通常会通过内存分配函数（如malloc）来动态申请一块内存空间。而释放内存时，则会调用相应的内存释放函数（如free）来释放内存。这种动态的内存分配和释放操作在频繁进行时，会产生很多开销，包括内存管理开销和内存碎片问题。
  - 而内存池就是为了解决这个问题而设计的。它事先申请一定大小的内存空间，并将其划分成多个固定大小的块，形成一个池子。当需要使用内存时，直接从内存池中分配一个可用的块，而不是频繁地调用内存分配函数。在释放内存时，将内存块归还给内存池，而不是调用内存释放函数。
  - 使用内存池的好处是可以降低内存碎片问题，减少动态内存分配和释放的开销。通过一次性申请和释放内存块，可以提高内存分配和释放的效率，从而提升程序性能。此外，内存池还可以提供内存分配的可预测性，**避免因动态内存分配造成的不确定性和性能抖动**。

- ==RTOS堆栈溢出==的检测

  方案1：在调度时检查栈指针是否越界（任务保存有栈顶和栈大小信息，每次切换时检查栈指针是否越界）

  - 优点：检测较快
  - 缺点：对于任务运行时溢出，而切换前又恢复正常的情况无法检测

  方案2：在调度时检查栈末尾的16个字节是否发生改变（创建任务时初始化为特定字符，每次切换时判断是否被改写）

  - 优点：可检出几乎所有溢出
  - 缺点：检测较慢

### ==HOOK函数==

* vApplicationIdleHook()
  idle的hook函数
* vApplicationTickHook()
  系统tick的hook函数
* vApplicationMallocFailedHook()
  malloc失败的hook函数
* vApplicationStackOverflowHook()
  栈溢出的hook函数
* vApplicationDaemonTaskStartupHook()
  vTaskStartScheduler()函数第一次执行的时候调用。

### ==栈溢出检测的2种方法==

* 第一种
  每次调度都检查一下任务的当前栈有没有超过任务的栈区域。
* 第二种
  每个任务栈最下面会有16个字节是特定的内容，每次调度的时候如果发现这16个字节不正常了，就说明有谁踩到了这个栈。

### ==异常和中断==

- freertos关闭中断

```c
#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY  // 此宏用来设置FreeRTOS系统可管理的最大优先级，也就是BASEPRI寄存器中存放的阈值。
// 关中断
// 向basepri中写入configMAX_SYSCALL_INTERRUPT_PRIORITY,
// 表明优先级低于configMAX_SYSCALL_INTERRUPT_PRIORITY的中断都会被屏蔽
static portFORCE_INLINE void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI = configMAX_SYSCALL_INTERRUPT_PRIORITY;

    __asm
    {
        msr basepri, ulNewBASEPRI
        dsb
        isb
    }
}
```

- 中断优先级

  - 设置FreeRTOS系统可管理的最大优先级，也就是高于5的优先级（小于5的优先级），FreeRTOS不管。

    ```c
    #define configLIBRARY_LOWEST_INTERRUPT_PRIORITY			15       //中断最低优先级(0-15)
    #define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY	5        //系统可管理的最高中断优先级
    ```

    ![img](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/20190823151313168.png)

- ==临界区==

  - 进入临界区的两种方式

    ```c
    taskENTER_CRITICAL();
    {
        .............// 临界区，关闭中断
    }
    taskEXIT_CRITICAL();
    
    vTaskSuspendAll();
    {
        .............// 临界区，仅关闭调度器，但响应中断
    }
    xTaskResumeAll();
    ```




## Linux

### ==基础命令==

|      | 命令                                              | 功能说明                                                     |
| ---- | :------------------------------------------------ | :----------------------------------------------------------- |
| ⭐    | **线上查询及帮助命令 (2 个)**                     |                                                              |
| ⭐    | **man**                                           | 查看命令帮助，命令的词典，更复杂的还有 info，但不常用。      |
| ⭐    | **help**                                          | 查看 Linux 内置命令的帮助，比如 cd 命令。                    |
| ⭐    | **文件和目录操作命令 (18 个)**                    |                                                              |
| ⭐    | **ls**                                            | 全拼 list，功能是列出目录的内容及其内容属性信息。            |
| ⭐    | **cd**                                            | 全拼 change directory，功能是从当前工作目录切换到指定的工作目录。 |
| ⭐    | **cp**                                            | 全拼 copy，其功能为复制文件或目录。                          |
| ⭐    | **find**                                          | 查找的意思，用于查找目录及目录下的文件。                     |
| ⭐    | **mkdir**                                         | 全拼 make directories，其功能是创建目录。                    |
| ⭐    | **mv**                                            | 全拼 move，其功能是移动或重命名文件。                        |
| ⭐    | **pwd**                                           | 全拼 print working directory，其功能是显示当前工作目录的绝对路径。 |
| ⭐    | **rename**                                        | 用于重命名文件。                                             |
| ⭐    | **rm**                                            | 全拼 remove，其功能是删除一个或多个文件或目录。              |
| ⭐    | **rmdir**                                         | 全拼 remove empty directories，功能是删除空目录。            |
| ⭐    | **touch**                                         | 创建新的空文件，改变已有文件的时间戳属性。                   |
| ⭐    | **tree**                                          | 功能是以树形结构显示目录下的内容。                           |
| ⭐    | **basename**                                      | 显示文件名或目录名。                                         |
| ⭐    | **dirname**                                       | 显示文件或目录路径。                                         |
|      | **chattr**                                        | 改变文件的扩展属性。                                         |
|      | **lsattr**                                        | 查看文件扩展属性。                                           |
| ⭐    | **file**                                          | 显示文件的类型。                                             |
|      | **md5sum**                                        | 计算和校验文件的 MD5 值。                                    |
|      | **查看文件及内容处理命令（21 个）**               |                                                              |
| ⭐    | **cat**                                           | 全拼 concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。 |
| ⭐    | **tac**                                           | tac 是 cat 的反向拼写，因此命令的功能为反向显示文件内容。    |
| ⭐    | **more**                                          | 分页显示文件内容。                                           |
| ⭐    | **less**                                          | 分页显示文件内容，more 命令的相反用法。                      |
| ⭐    | **head**                                          | 显示文件内容的头部。                                         |
| ⭐    | **tail**                                          | 显示文件内容的尾部。                                         |
| ⭐    | **cut**                                           | 将文件的每一行按指定分隔符分割并输出。                       |
| ⭐    | **split**                                         | 分割文件为不同的小片段。                                     |
|      | **paste**                                         | 按行合并文件内容。                                           |
|      | **sort**                                          | 对文件的文本内容排序。                                       |
|      | **uniq**                                          | 去除重复行。oldboy                                           |
|      | **wc**                                            | 统计文件的行数、单词数或字节数。                             |
|      | **iconv**                                         | 转换文件的编码格式。                                         |
|      | **dos2unix**                                      | 将 DOS 格式文件转换成 UNIX 格式。                            |
|      | **diff**                                          | 全拼 difference，比较文件的差异，常用于文本文件。            |
|      | **vimdiff**                                       | 命令行可视化文件比较工具，常用于文本文件。                   |
|      | **rev**                                           | 反向输出文件内容。                                           |
| ⭐    | **grep/egrep**                                    | 过滤字符串，三剑客老三。<br />-C：匹配的上下文分别显示[number]行。<br/>-I：不区分大小写(只适用于单字符)。<br/>-i：不区分大小写。<br/>-h：查询多文件时不显示文件名。<br/>-l：查询多文件时只输出包含匹配字符的文件名。<br/>-L：列出不匹配的文件名。<br/>-n：显示匹配行及 行号。<br/>-s：不显示不存在或无匹配文本的错误信息。<br/>-v：显示不包含匹配文本的所有行。<br/>-w：只匹配整个单词。<br/>-E：扩展的正则表达式<br/>-R：递归搜寻<br/>--exclude=FILE：跳过FILE |
| ⭐    | **join**                                          | 按两个文件的相同字段合并。                                   |
| ⭐    | **tr**                                            | 替换或删除字符。                                             |
| ⭐    | **vi/vim**                                        | 命令行文本编辑器。                                           |
|      | **文件压缩及解压缩命令（4 个）**                  |                                                              |
| ⭐    | **tar**                                           | 打包压缩。oldboy                                             |
| ⭐    | **unzip**                                         | 解压文件。                                                   |
|      | **gzip**                                          | gzip 压缩工具。                                              |
| ⭐    | **zip**                                           | 压缩工具。                                                   |
| ⭐    | **信息显示命令（11 个）**                         |                                                              |
| ⭐    | **uname**                                         | 显示操作系统相关信息的命令。                                 |
| ⭐    | **hostname**                                      | 显示或者设置当前系统的主机名。                               |
| ⭐    | **dmesg**                                         | 显示开机信息，用于诊断系统故障。                             |
| ⭐    | **uptime**                                        | 显示系统运行时间及负载。                                     |
| ⭐    | **stat**                                          | 显示文件或文件系统的状态。                                   |
| ⭐    | **du**                                            | 计算磁盘空间使用情况。                                       |
| ⭐    | **df**                                            | 报告文件系统磁盘空间的使用情况。                             |
| ⭐    | **top**                                           | 实时显示系统资源使用情况。                                   |
| ⭐    | **free**                                          | 查看系统内存。                                               |
| ⭐    | **date**                                          | 显示与设置系统时间。                                         |
| ⭐    | **cal**                                           | 查看日历等时间信息。                                         |
| ⭐    | **搜索文件命令（4 个）**                          |                                                              |
|      | **which**                                         | 查找二进制命令，按环境变量 PATH 路径查找。                   |
|      | **find**                                          | 从磁盘遍历查找文件或目录。<br />-name     按照文件名<br/>-iname     按照文件名 忽略大小写<br/>-perm     按照文件权限<br/>-user     按照文件拥有者<br/>-group    按照文件所属的组<br/>-mtime -n +n 按照文件的更改时间来查找文件， -n：n天以内，+n：n天以前<br/>-type     查找某一类型：文件类型有：普通文件(f)，目录(d)，字符设备文件(c)，块设备文件(b)，符号链接文件(l)，套接字文件(s)，管道文件(p)<br/>-size n   查找文件长度为n块（一块等于512字节）的文件，带有c时表示文件长度以字节计。 <br/>-mount    不跨越文件系统<br/>-follow   遇到符号链接文件，就跟踪至链接所指向的文件<br/>-path     匹配文件路径或者文件<br/>-exec     执行后续命令操作<br/>-a        and 与操作<br/>-o        or  或操作<br/>-not      not 非操作 |
|      | **whereis**                                       | 查找二进制命令，按环境变量 PATH 路径查找。                   |
|      | **locate**                                        | 从数据库 (/var/lib/mlocate/mlocate.db) 查找命令，使用 updatedb 更新库。 |
|      | **用户管理命令（10 个）**                         |                                                              |
|      | **useradd**                                       | 添加用户。                                                   |
|      | **usermod**                                       | 修改系统已经存在的用户属性。                                 |
|      | **userdel**                                       | 删除用户。                                                   |
|      | **groupadd**                                      | 添加用户组。                                                 |
|      | **passwd**                                        | 修改用户密码。                                               |
|      | **chage**                                         | 修改用户密码有效期限。                                       |
|      | **id**                                            | 查看用户的 uid,gid 及归属的用户组。                          |
|      | **su**                                            | 切换用户身份。                                               |
|      | **visudo**                                        | 编辑 / etc/sudoers 文件的专属命令。                          |
|      | **sudo**                                          | 以另外一个用户身份（默认 root 用户）执行事先在 sudoers 文件允许的命令。 |
|      | **基础网络操作命令（11 个）**                     |                                                              |
|      | **telnet**                                        | 使用 TELNET 协议远程登录。                                   |
|      | **ssh**                                           | 使用 SSH 加密协议远程登录。                                  |
|      | **scp**                                           | 全拼 secure copy，用于不同主机之间复制文件。                 |
|      | **wget**                                          | 命令行下载文件。                                             |
| ⭐    | **ping**                                          | 测试主机之间网络的连通性。                                   |
|      | **route**                                         | 显示和设置 linux 系统的路由表。                              |
| ⭐    | **ifconfig**                                      | 查看、配置、启用或禁用网络接口的命令。                       |
|      | **ifup**                                          | 启动网卡。                                                   |
|      | **ifdown**                                        | 关闭网卡。                                                   |
|      | **netstat**                                       | 查看网络状态。                                               |
|      | **ss**                                            | 查看网络状态。                                               |
|      | **深入网络操作命令（9 个）**                      |                                                              |
|      | **nmap**                                          | 网络扫描命令。                                               |
|      | **lsof**                                          | 全名 list open files，也就是列举系统中已经被打开的文件。     |
|      | **mail**                                          | 发送和接收邮件。                                             |
|      | **mutt**                                          | 邮件管理命令。                                               |
|      | **nslookup**                                      | 交互式查询互联网 DNS 服务器的命令。                          |
|      | **dig**                                           | 查找 DNS 解析过程。                                          |
|      | **host**                                          | 查询 DNS 的命令。                                            |
|      | **traceroute**                                    | 追踪数据传输路由状况。                                       |
|      | **tcpdump**                                       | 命令行的抓包工具。                                           |
|      | **有关磁盘与文件系统的命令（16 个）**             |                                                              |
| ⭐    | **mount**                                         | 挂载文件系统。                                               |
| ⭐    | **umount**                                        | 卸载文件系统。                                               |
|      | **fsck**                                          | 检查并修复 Linux 文件系统。                                  |
|      | **dd**                                            | 转换或复制文件。                                             |
|      | **dumpe2fs**                                      | 导出 ext2/ext3/ext4 文件系统信息。                           |
|      | **dump**                                          | ext2/3/4 文件系统备份工具。                                  |
| ⭐    | **fdisk**                                         | 磁盘分区命令，适用于 2TB 以下磁盘分区。                      |
|      | **parted**                                        | 磁盘分区命令，没有磁盘大小限制，常用于 2TB 以下磁盘分区。    |
|      | **mkfs**                                          | 格式化创建 Linux 文件系统。                                  |
|      | **partprobe**                                     | 更新内核的硬盘分区表信息。                                   |
|      | **e2fsck**                                        | 检查 ext2/ext3/ext4 类型文件系统。                           |
|      | **mkswap**                                        | 创建 Linux 交换分区。                                        |
|      | **swapon**                                        | 启用交换分区。                                               |
|      | **swapoff**                                       | 关闭交换分区。                                               |
| ⭐    | **sync**                                          | 将内存缓冲区内的数据写入磁盘。                               |
|      | **resize2fs**                                     | 调整 ext2/ext3/ext4 文件系统大小。                           |
|      | **系统权限及用户授权相关命令（4 个）**            |                                                              |
| ⭐    | **chmod**                                         | 改变文件或目录权限。                                         |
|      | **chown**                                         | 改变文件或目录的属主和属组。                                 |
|      | **chgrp**                                         | 更改文件用户组。                                             |
|      | **umask**                                         | 显示或设置权限掩码。                                         |
|      | **查看系统用户登陆信息的命令（7 个）**            |                                                              |
|      | **whoami**                                        | 显示当前有效的用户名称，相当于执行 id -un 命令。             |
| ⭐    | **who**                                           | 显示目前登录系统的用户信息。                                 |
|      | **w**                                             | 显示已经登陆系统的用户列表，并显示用户正在执行的指令。       |
|      | **last**                                          | 显示登入系统的用户。                                         |
|      | **lastlog**                                       | 显示系统中所有用户最近一次登录信息。                         |
|      | **users**                                         | 显示当前登录系统的所有用户的用户列表。                       |
|      | **finger**                                        | 查找并显示用户信息。                                         |
|      | **内置命令及其它（19 个）**                       |                                                              |
| ⭐    | **echo**                                          | 打印变量，或直接输出指定的字符串                             |
| ⭐    | **printf**                                        | 将结果格式化输出到标准输出。                                 |
| ⭐    | **rpm**                                           | 管理 rpm 包的命令。                                          |
|      | **yum**                                           | 自动化简单化地管理 rpm 包的命令。                            |
|      | **watch**                                         | 周期性的执行给定的命令，并将命令的输出以全屏方式显示。       |
|      | **alias**                                         | 设置系统别名。                                               |
|      | **unalias**                                       | 取消系统别名。                                               |
|      | **date**                                          | 查看或设置系统时间。                                         |
|      | **clear**                                         | 清除屏幕，简称清屏。                                         |
|      | **history**                                       | 查看命令执行的历史纪录。                                     |
|      | **eject**                                         | 弹出光驱。                                                   |
|      | **time**                                          | 计算命令执行时间。                                           |
|      | **nc**                                            | 功能强大的网络工具。                                         |
|      | **xargs**                                         | 将标准输入转换成命令行参数。                                 |
| ⭐    | **exec**                                          | 调用并执行指令的命令。                                       |
|      | **export**                                        | 设置或者显示环境变量。                                       |
|      | **unset**                                         | 删除变量或函数。                                             |
|      | **type**                                          | 用于判断另外一个命令是否是内置命令。                         |
|      | **bc**                                            | 命令行科学计算器                                             |
|      | **系统管理与性能监视命令 (9 个)**                 |                                                              |
|      | **chkconfig**                                     | 管理 Linux 系统开机启动项。                                  |
|      | **vmstat**                                        | 虚拟内存统计。                                               |
|      | **mpstat**                                        | 显示各个可用 CPU 的状态统计。                                |
|      | **iostat**                                        | 统计系统 IO。                                                |
|      | **sar**                                           | 全面地获取系统的 CPU、运行队列、磁盘 I/O、分页（交换区）、内存、 CPU 中断和网络等性能数据。 |
|      | **ipcs**                                          | 用于报告 Linux 中进程间通信设施的状态，显示的信息包括消息列表、共享内存和信号量的信息。 |
|      | **ipcrm**                                         | 用来删除一个或更多的消息队列、信号量集或者共享内存标识。     |
|      | **strace**                                        | 用于诊断、调试 Linux 用户空间跟踪器。我们用它来监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。 |
|      | **ltrace**                                        | 命令会跟踪进程的库函数调用, 它会显现出哪个库函数被调用。     |
|      | **关机 / 重启 / 注销和查看系统信息的命令（7个）** |                                                              |
|      | **shutdown**                                      | 关机。                                                       |
|      | **halt**                                          | 关机。就是调用shutdown -h。                                  |
|      | **poweroff**                                      | 关闭电源。                                                   |
|      | **logout**                                        | 退出当前登录的 Shell。                                       |
|      | **exit**                                          | 退出当前登录的 Shell。                                       |
|      | **reboot**                                        | 工作过程差不多跟halt一样﹐不过它是引发主机重启               |
|      | **Ctrl+d**                                        | 退出当前登录的 Shell 的快捷键。                              |
|      | **进程管理相关命令（15 个）**                     |                                                              |
|      | **bg**                                            | 将一个在后台暂停的命令，变成继续执行 （在后台执行）。        |
|      | **fg**                                            | 将后台中的命令调至前台继续运行。                             |
|      | **jobs**                                          | 查看当前有多少在后台运行的命令。                             |
|      | **kill**                                          | 终止进程。                                                   |
|      | **killall**                                       | 通过进程名终止进程。                                         |
|      | **pkill**                                         | 通过进程名终止进程。                                         |
|      | **crontab**                                       | 定时任务命令。                                               |
|      | **ps**                                            | 显示进程的快照。                                             |
|      | **pstree**                                        | 树形显示进程。                                               |
|      | **nice/renice**                                   | 调整程序运行的优先级。                                       |
|      | **nohup**                                         | 忽略挂起信号运行指定的命令。                                 |
|      | **pgrep**                                         | 查找匹配条件的进程。                                         |
|      | **runlevel**                                      | 查看系统当前运行级别。                                       |
|      | **init**                                          | 切换运行级别。                                               |
|      | **service**                                       | 启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。 |
|      |                                                   |                                                              |
|      | **insmod**                                        | 加载模块                                                     |
|      | **rmmod**                                         | 卸载模块                                                     |

#### grep

```shell
grep "^a" a.txt   ## 查找以a开头的行
grep "^a.*r$" a.txt   ## 同时查找以a开头同时以r结尾的行
grep "^a.*h.*r$" a.txt  ## 同时查找以a开头，包含字符h，并以r结尾的行
grep "^a\|e$" a.txt  ## 提取以a开头，或者以e结尾的行

\ 反义字符：如"\"\""表示匹配""
[ - ] 匹配一个范围，[0-9a-zA-Z]匹配所有数字和字母
* 所有字符，长度可为0
+ 前面的字符出现了一次或者多次
^ #匹配行的开始 如：'^grep'匹配所有以grep开头的行。
$ #匹配行的结束 如：'grep$'匹配所有以grep结尾的行。
. #匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。
* #匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。
.* #一起用代表任意字符。
[] #匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。
[^] #匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。
\(..\) #标记匹配字符，如'\(love\)'，love被标记为1。
\< #到匹配正则表达式的行开始，如:'\<grep'匹配包含以grep开头的单词的行。
\> #到匹配正则表达式的行结束，如'grep\>'匹配包含以grep结尾的单词的行。
x\{m\} #重复字符x，m次，如：'0\{5\}'匹配包含5个o的行。
x\{m,\} #重复字符x,至少m次，如：'o\{5,\}'匹配至少有5个o的行。
x\{m,n\} #重复字符x，至少m次，不多于n次，如：'o\{5,10\}'匹配5--10个o的行。
\w #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。
\W #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。
\b #单词锁定符，如: '\bgrep\b'只匹配grep。
```

### ==内存管理==

#### 概念

- 内存管理的作用

  - 内存分配与回收
  - 采用虚拟内存进行扩容
  - 负责逻辑地址到物理地址的转换
  - 实现内存保护与隔离（应用间、内核隔离）

- Linux内存管理对于每个进程完成从虚拟内存到物理内存的转换

  <img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/70-16709318849786.png" alt="img" style="zoom:67%;" />

- 虚拟内存

  - 一种内存管理技术，它将计算机的物理内存和磁盘上的虚拟内存空间进行映射和管理。它使得每个进程拥有独立的地址空间，从而提供了更大的可用内存空间。虚拟内存允许进程使用超过实际物理内存容量的内存，将不常用的数据存储在磁盘上，并通过页面调度算法将其加载到物理内存中。其在操作系统中的作用是：
    - `虚拟内存管理`：虚拟内存技术使得系统可以在有限的物理内存情况下运行更多的进程，并提供了更大的地址空间。它通过将不常用的数据存储在磁盘上，将内存需求高效地管理起来。
    - `页面调度和换入/换出`：虚拟内存使用页面调度算法决定哪些页面需要置换到磁盘上，以及何时将其换入物理内存。这些算法根据访问模式和优先级来优化内存的使用效率和性能。

- 虚拟内存和物理内存

  - `物理内存`是计算机硬件中用于存储数据和指令的实际硬件内存。它是由随机存取存储器（RAM）组成的，以字节为单位存储数据。物理内存是实际存在于计算机系统中的存储区域，用于存储正在运行的程序、操作系统和其他数据。
    - `虚拟内存`是一种在操作系统层面上提供的抽象概念，它扩展了物理内存的容量。虚拟内存使用硬盘上的一部分空间作为辅助存储区域，并将其视为扩展的内存。通过虚拟内存，每个进程都拥有自己的虚拟地址空间，可以访问比物理内存更大的地址范围。
    - 虚拟内存和物理内存之间的映射关系是`通过操作系统的内存管理单元（MMU）来实现`的。MMU负责将进程的虚拟地址转换为物理地址。具体工作流程原理如下：
      - 当进程访问虚拟内存中的数据时，MMU将虚拟地址划分为页面（通常是固定大小的块），然后将这些页面映射到物理内存中的对应位置。这样，虚拟内存中的页面可以分散地存储在物理内存中的不同位置。当进程访问虚拟内存中的某个页面时，MMU会将对应的物理地址提供给内存控制器，从而读取或写入真正的物理内存。
      - 虚拟内存的映射关系可以动态地进行调整，以便在物理内存不足时进行页面置换（将不常用的页面从物理内存移到磁盘），从而为进程提供更大的地址空间。当进程访问被置换到磁盘上的页面时，操作系统会将该页面重新调入物理内存，并更新虚拟内存的映射关系。


#### MMU

- Cortex-M能否运行Linux，其不存在硬件的MMU（内存管理单元）（将硬件物理地址映射到虚拟地址并做检查）；STM32MP1（Cortex-A7）可运行Linux；

#### 内存映射

- 内存映射是一种将物理内存或设备寄存器映射到逻辑地址空间的技术。通过内存映射，物理内存和设备寄存器被映射为逻辑地址，使得处理器和其他系统组件可以通过逻辑地址来访问它们。在嵌入式系统中使用内存映射有以下几个原因：
  - `统一访问接口`：通过内存映射，嵌入式系统可以将外设的寄存器和物理内存映射到统一的逻辑地址空间中。这样，处理器可以使用相同的指令和地址访问这些设备，无需编写特定的设备驱动程序。这种统一的访问接口简化了系统设计和软件开发。
   - `简化访问操作`：内存映射使得对外设寄存器的访问变得像对内存的访问一样简单。处理器可以使用读写内存的指令来读取和写入设备寄存器的值，从而简化了对外设的控制和配置。
   - `内存保护和安全性`：内存映射可用于实现内存保护和安全性。通过将不同的内存区域映射到不同的地址空间中，并设置相应的访问权限，可以限制对某些关键数据和代码的访问。这提高了系统的安全性，并防止对内存的非法访问和修改。
   - `虚拟内存管理`：内存映射还可用于虚拟内存管理。通过将物理内存映射到虚拟地址空间中，嵌入式系统可以实现虚拟内存的功能，包括内存分页、页面置换和内存共享等。这提供了更灵活和高效的内存管理机制，使系统能够有效地利用有限的物理内存资源。
- 

#### 内存寻址

- TLB（Translation Lookaside Buffer）

页表的cache，也称为快表，属于MMU的一部分

- TLB、页表、Cache、主存之间的访问关系

首先，程序员应该给出一个逻辑地址。通过逻辑地址去查询TLB和页表（一般是同时查询，TLB是页表的子集，所以TLB命中，页表一定命中；但是页表命中，TLB不一定命中），以确定该数据是否在主存中。因为只要TLB和页表命中，该数据就一定被调入主存。如果TLB和页表都不命中，则代表该数据就不在主存，所以必定会导致Cache访问不命中。现在，假设该数据在主存中，那么Cache也不一定会命中，因为Cache里面的数据仅仅是主存的一小部分。

#### 分页段式内存管理

- `分页（Paging）`：在分页内存管理方式中，虚拟地址空间和物理内存都被划分为固定大小的页面（通常是4KB或8KB）。虚拟地址空间中的每个页面被映射到物理内存中的一个页面。这种映射是通过页表来实现的，页表存储了虚拟页面和物理页面之间的映射关系。当进程访问一个虚拟地址时，操作系统使用虚拟地址的高位来索引页表，找到对应的页表项，其中包含了物理页面的地址。通过将虚拟地址的低位与页表项中的偏移量进行组合，就可以得到对应的物理地址。分页的优点是地址空间的连续性和共享页面的能力，但也会带来内部碎片和页表的开销。
  - `分段（Segmentation）`：在分段内存管理方式中，虚拟地址空间和物理内存都被划分为不同大小的段。每个段都有一个基址和长度，表示该段在物理内存中的起始位置和长度。虚拟地址空间中的每个段被映射到物理内存中的一个段。当进程访问一个虚拟地址时，操作系统使用虚拟地址的段选择子来索引段描述符表，找到对应的段描述符，其中包含了物理段的基址和长度。通过将虚拟地址的偏移量与段描述符中的基址进行组合，就可以得到对应的物理地址。分段的优点是灵活的地址空间分配和保护，但也会带来外部碎片和段表的开销。

定义：将内存分为大小相等的页框、进程也分为页框，OS将进程的页框一一对应放入内存

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230703161633033.png" alt="image-20230703161633033" style="zoom:50%;" />

在进程控制块PCB中存放页表，记录了进程页号和内存块号之间的对应关系

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230703162109683.png" alt="image-20230703162109683" style="zoom:67%;" />

#### 页表

带有权限属性，放在物理内存中的，用来**记录虚拟内存页与物理页映射关系**的一张表

功能：（虚拟地址与物理地址转换）、（隔离各进程）、（各进程分配连续空间）、（权限管理RW）

|              | 一级页表                                                   | 多级页表                         | 快表                       |
| ------------ | ---------------------------------------------------------- | -------------------------------- | -------------------------- |
| 内存访问速度 | 2次（访问页表+访问数据）                                   | 多次（访问一级、二级后访问数据） | 用高速缓存存放常用的页表项 |
| 空间利用率   | 低，虚拟内存越大，页表越大，内存碎片化严重（页表数量限制） | 高，按需分配各级页表             | /                          |

#### 逻辑地址和物理地址

1. 依据逻辑地址，整除页面大小得到页号，余数为页内偏移量
2. 判断越界
3. 通过PCB中保存的页表查询该页存放在哪一块内存（逻辑内存地址）
4. 通过逻辑内存地址计算实际物理内存地址

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230703164233310.png" alt="image-20230703164233310" style="zoom: 50%;" />

#### 缺页中断

为了使得页表不用常驻内存，将页表分为2级管理，1级页表存储页表索引，2级页表存储内存逻辑地址

当某些页面不在内存中但被访问到时发生缺页中断

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230703173202523.png" alt="image-20230703173202523" style="zoom:50%;" />

#### 虚拟内存

- 将即将使用的数据装入内存，若内存满了，将不用的数据换入磁盘
- 第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
- 第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。 第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。
- 通过地址转换，使得应用程序运行在连续内存上，且与内核隔离

#### 内存碎片

- 内存碎片分为内碎片与外碎片
  - 外碎片：还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。
  - 内碎片：已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；（按固定大小分配给进程）
  - 产生原因：分配较多不连续的空间后，剩余可用空间被孤立



- Linux栈大小
  - Linux栈的大小可以在编译内核时进行配置，并且可以根据系统需求进行调整。栈的大小决定了每个线程的可用栈空间大小。
  - 在大多数Linux系统上，默认的栈大小为8MB。但是，这个值并不是固定的，可以通过修改内核参数或使用特定的命令来改变栈的大小。

#### 内存分配

- malloc的底层实现

  调用malloc时，去内存空闲链表内寻找可分配的空间，返回首地址指针

  以RTT为例：内存管理方法可分为一、内存堆管理（小内存、slab大内存、多内存memheap）与二、内存池管理

  一、内存堆管理`

  ​		小内存管理：从整块内存中通过链表寻找空闲内存块（逐一向后寻找匹配空间）

  <img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/08smem_work.png" alt="小内存管理工作机制图" style="zoom: 80%;" />

  ​		slab：将整块内存分为多个不同大小的类别（对号入座）适合于大量的、细小的数据结构的内存申请的情况

  <img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/08slab.png" alt="slab 内存分配结构图" style="zoom: 80%;" />

  ​		memheap：多个地址不连续内存，将其连接起来使用

  <img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/08memheap.png" alt="memheap 处理多内存堆" style="zoom:80%;" />

  二、内存池管理

  ​		内存池：类似slab，分配大块内存

  <img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/08mempool_work.png" alt="内存池工作机制图" style="zoom:80%;" />

  对比：

  | 分配算法 | 优点               | 缺点                         | 使用场景       |
  | -------- | ------------------ | ---------------------------- | -------------- |
  | 内存堆   | 可分配任意大小内存 | 每次均需要查找、容易产生碎片 | 大量细小内存   |
  | 内存池   | 分配高效           | 无法分配小内存               | 块设备大量数据 |

- brk()与mmap()

  - 在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk（C++）sbrk（C），mmap，munmap这些系统调用实现的

    进程分配内存的方式有两种系统调用方式：brk与mmap

    - brk是将数据段(.data)的最高地址指针_edata往高地址推（高地址释放后低地址才能释放，只适用于小内存分配，碎片多）
    - mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存（可以单独释放，碎片少）

    相同点：分配的都是虚拟内存，首次访问时发生缺页中断，操作系统再负责分配物理内存，随后建立映射关系

    ![img](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NodXppc2hpag==,size_16,color_FFFFFF,t_70-16711754442818.png)

    ![img](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NodXppc2hpag==,size_16,color_FFFFFF,t_70.png)

    ![img](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NodXppc2hpag==,size_16,color_FFFFFF,t_70-16711754138065.png)

#### FLEX RAM

- TCM : Tightly-Coupled Memory 紧密耦合内存 。ITCM用于指令，DTCM用于数据，**特点是跟内核速度一样**（400MHz），而片上RAM的速度基本都达不到这个速度（200MHz）。很多时候我们希望将需要实时性的程序和变量分别放在ITCM和DTCM里面执行，本章就是解决这个问题。

1. ITCM（指令紧耦合存储器）：
   - ITCM用于存储指令（程序代码），通常具有较低的访问延迟和较高的带宽，以提供快速和可预测的指令访问。
   - ITCM通常与处理器核心直接相连，使得指令可以快速地从该存储区加载，从而加快指令执行速度。
   - ITCM的容量相对较小，通常只能存储少量的指令代码。
2. DTCM（数据紧耦合存储器）：
   - DTCM用于存储数据，如变量、栈、堆等，具有较低的读写访问延迟和高带宽。
   - DTCM与处理器核心直接相连，以提供快速的数据访问，使得数据可以快速加载和存储，提高数据操作的效率。
   - DTCM的容量通常相对较小，只能存储有限量的数据。
3. OCRAM（片上随机访问存储器）：
   - OCRAM是一种通用的片上随机访问存储器，用于存储数据和指令。
   - OCRAM的容量通常比ITCM和DTCM更大，可以存储更多的数据和代码。
   - OCRAM的访问速度和带宽一般较低，但相对来说会比外部存储器的访问速度快。

三者之间的主要区别在于其设计目标和功能。ITCM主要用于存储指令代码，提供快速指令访问；DTCM主要用于存储数据，提供快速数据访问；OCRAM则是一种通用存储器，可以同时存储指令和数据，容量相对较大，但速度和带宽可能不如ITCM和DTCM。

![img](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/v2-7e91f17b7c3b5c6834f90cf00b2dfb7a_720w.webp)

大家都知道 RAM 是掉电易失的，这种加速的方法如何在量产产品中使用呢？实际上使用以上的方法，MDK 会将特定的函数编译到 ROM 当中，在每次启动的时候都会将 ROM 中指定的函数拷贝到 RAM 放中。

#### 闪存FLASH和EEPROM

 闪存和EEPROM（Electrically Erasable Programmable Read-Only Memory）都是在嵌入式系统中常见的非易失性存储器，它们在系统中具有不同的作用和特点。

  1. `闪存`：闪存是一种非易失性存储器，常用于存储程序代码、操作系统和数据。它具有快速的读取速度和较大的存储容量，通常以`块`的形式进行读写操作。闪存具有擦除和编程的功能，允许数据被修改和更新。闪存通常分为 NOR Flash 和 NAND Flash 两种类型，它们在性能和应用场景上有所区别。在嵌入式系统中，闪存被广泛用于存储系统的固件、引导程序和应用程序等。它可提供长期存储和持久性的数据存储，确保系统在断电后能够保留数据和程序代码。闪存还具有较快的读取速度，支持随机访问，适用于需要频繁读取和写入数据的场景。

  2. `EEPROM`：EEPROM是一种电可擦除可编程只读存储器，它与闪存相似，但在擦除和编程方面更加灵活。EEPROM可以以`字节`的形式进行读写操作，而不需要擦除整个块。这使得EEPROM适用于频繁写入和更新数据的应用。在嵌入式系统中，EEPROM常用于存储配置数据、校准参数、设备状态和用户设置等。它可提供可编程的存储空间，允许数据在系统运行时被动态地修改和更新。由于EEPROM支持字节级的读写操作，它特别适用于存储小量数据的场景。

 区别：

  1. `存储方式`：闪存以块的形式进行读写操作，而EEPROM以字节的形式进行读写操作。
  2. `擦除和编程`：闪存通常需要整个块进行擦除和编程，而EEPROM可以在字节级别进行擦除和编程。
  3. `容量和性能`：闪存通常具有较大的存储容量和更快的`读取速度`，而EEPROM容量较小且`读取速度`较慢。
  4. `应用场景`：闪存适用于存储程序代码和大容量数据的场景，而EEPROM适用于存储配置数据和小容量数据的场景。

#### 手动释放内存

- 采用TOP命令查看内存张后，采用/proc/sys/vm/drop_caches来释放内存

  `[root@ipa]# echo 0~3 > /proc/sys/vm/drop_caches` 

  **drop_caches的值可以是0-3之间的数字，代表不同的含义：**
  0：不释放（系统默认值）
  1：释放页缓存
  2：释放dentries和inodes
  3：释放所有缓存

### ==中断和异常==

#### 异常

#### 中断

- 中断向量表
- 中断优先级

#### 信号（软中断）

- `信号`是一种用于通知进程发生某个事件或异常情况的机制。它是一种`软件中断`，可以从内核（操作系统的核心）发送给进程。当发生某个特定的事件或条件时，内核可以向进程发送一个信号，进程可以捕获并处理该信号。

### ==进程管理==

#### 概念

- 进程状态

  - 等待态，执行态，就绪态

  - 就绪态：一切条件都具备，只差 cpu 时间片到来

  - 等待态：缺少执行条件
  - 执行态：cpu 时间片到来，执行程序


    ![进程状态转换图](https://595lwl.oss-cn-shenzhen.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png#pic_center)

- 内核态和用户态

  - ==区别==运行级别，是否可以操作硬件。==用户态->内核态==：系统调用、异常、外围设备中断。

- 并发和并行

  - 并发：
    - CPU 将 1 s 分成若干时间碎片，每个时间碎片 CPU 只能执行一个进程的一小部分
    - 以时间碎片为单位，若干个进程循环占有 CPU ，并执行对应进程的一小部分
    - 经过 n 次循环占有 CPU,每个进程才能执行完毕
    - 总的来说：多个进程以时间碎片为单位，循环占有 CPU ，以完成同时执行的现象称为并发

  - 并行：并发发⽣在单核（只能有⼀个并发链），并⾏发⽣在多核（可以有多个并发链）

- 进程和线程

  - ==区别==

    1. 资源占用：==进程是资源分配的最小单位，线程是CPU调度的最小单位，进程有独立分配的内存空间，线程共享进程空间，真正在cpu上运行的是线程。进程切换开销大，线程轻量级==每个进程都有独立的内存空间，包括代码、数据、堆栈等，而线程共享所属进程的内存空间。因此，在创建、切换和销毁进程时，涉及到较大的资源开销，而线程切换和创建时的开销较小。
    2. 并发性：==进程并发性差==进程是独立运行的执行单位，多个进程之间可以并发，每个进程都有自己的执行状态、程序计数器和堆栈指针等。线程是进程内的执行流，多个线程共享进程的资源，在同一进程中的个线程可以并发执行。
    3. 通信和同步：进程间的通信比较复杂，需要通过特定的机制（如==管道、消息队列==等）进行数据的传递和共享。而线程之间共享进程的资源，通信相对容易，可以直接访问==共享的内存变量==。在多线程编程中，线程之间需要通过同步机制（如==锁、信号量、条件变量==等）来保证数据的一致性和正确性。
    4. 安全性：由于线程共享进程的资源，多个线程之间对共享数据的访问需要进行同步控制，否则可能会出现竞争条件（Race Condition）和数据不一致的问题。相比之下，进程间的数据相对独立，每个进程拥有独立的内存空间，更加安全。

  - ==线程控制块TCB与进程控制块PCB==

    - PCB 中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息。
      - PCB 的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。或者说，OS 是根据 PCB 来对并发执行的进程进行控制和管理的。例如，当 OS 要调度某进程执行时，要从该进程的 PCB 中查处其现行状态及优先级；在调度到某进程后，要根据其 PCB 中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其 PCB 中的程序和数据的内存始址，找到其程序和数据；进程在执行过程中，当需要和与之合作的进程实现同步，通信或者访问文件时，也都需要访问 PCB；当进程由于某种原因而暂停执行时，又须将器断点的处理机环境保存在 PCB 中。
      - 可见，在进程的整个生命期中，系统总是通过 PCB 对进程进行控制的，即系统是根据进程的 PCB 而不是任何别的什么而感知到该进程的存在的。所以说，PCB 是进程存在的唯一标志。
    - PCB：

      - 进程ID
      - 进程状态寄存器
      - 锁、信号量等同步机制与上下文信息
      - 进程优先级、等待时间等其他内存
      - 内存空间范围
      - 线程状态
      - 文件描述符
    - TCB：

      - 线程ID
      - 线程状态寄存器
      - 锁、信号量等同步机制与上下文信息
      - 线程优先级

  - ==多进程和多线程==

    - 多进程：

      - 优点：进程独立，不影响主程序稳定性，可多CPU运行
      - 缺点：逻辑复杂，IPC通信困难，调度开销大

    - 多线程：
      - 优点：线程间通信方便，资源开销小，程序逻辑简单
      - 缺点：线程间独立互斥困难，线程崩溃影响进程
    - 选择：频繁创建的用线程，CPU密集用进程，IO密集用线程
    - **总结：安全稳定选进程，快速频繁选线程**

  - ==上下文切换：进程切换和线程切换==

    - 进程切换比线程切换慢
    - 进程切换涉及到页表的切换，页表的切换实质上导致TLB的缓存全部失效，这些寄存器里的内容需要全部重写。而线程切换无需经历此步骤。
      - PCB、CPU通用寄存器、浮点寄存器、用户栈、内核数据结构（页表、进程表、文件表）
    - 线程切换涉及到线程栈
      - TCB信息
      - 寄存器状态：如R0-R3、SP、LR、PC等
      - 程序状态字：如程序处于中断、用户态、内核态等标志位
      - 堆栈：线程执行期间所用的变量等信息
      - 浮点FPU寄存器

  - ==进程可以创建线程数量==

    - （可用虚拟空间和线程的栈的大小共同决定）一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程

  - ==例子==

    - 线程在进程下行进（单纯的车厢无法运行）
    - 一个进程可以包含多个线程（一辆火车可以有多个车厢）
    - 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
    - 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
    - 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
    - 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响另外一列火车，但如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
    - 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
    - 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如洗手间）－"互斥锁"
    - 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

  - ==父子进程、僵尸、孤儿==

    - 子进程：父进程执行fork()系统调用，复制出一个和自身基本一致的进程为子进程，随后执行exec()系统调用，父进程执行其他任务

    - 孤儿进程： 父进程生成子进程，但是父进程比子进程先结束，系统在子进程结束后回收资源

      - 孤儿会被 init 进程领养（ init 进程是所有孤儿进程的父进程）

      - 为了子进程结束后，可以回收子进程占有的系统资源（进程结束后，子进程自己能够释放用户区空间，但无法释放 PCB 只能由父亲释放）

    - 僵尸进程：子进程已经退出，但是没有父进程回收子进程的资源（PCB）

      -  一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。

      - 解决方法

        - 通过信号机制：子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。

        - fork两次：父进程创建子进程A，子进程A再创建子进程B，然后子进程A退出，进程B就交给init进程处理了。init进程可以处理僵尸进程.

        - ```
          ps -A -ostat,pid,cmd |grep -iE '^z'
          -A 显示所有任务
          -o 按照指定格式输出
          grep -iE 显示z开头的行，不区分大小写
          ```

    - fork()：建立一个新的子进程。其子进程会复制父进程的数据与堆栈空间，并继承已打开的文件代码、工作目录和资源限制等

  - ==死锁的原因、条件==

    - 两个或两个以上的进程在，因争夺资源而造成的一种互相等待的现象
    - 原因：资源不足、分配不当、推进顺序不合适
    - 条件：（1） **互斥条件**：一个资源每次只能被一个进程使用。
      ​		（2） **不剥夺条件**：进程已获得的资源，在末释放前，不能强行剥夺。
      ​		（3） **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
      ​		（4） **循环等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系。
    - 解除与预防：打破上述一个条件即可

- fork函数

  - fork是用来创建子进程的，这个函数的特别之处在于一次调用，两次返回，一次返回到父进程中，一次返回到子进程中，我们可以通过返回值来判断其返回点：

    ```c
    pid_t child = fork();
    if( child < 0  ) {     //fork error.
        perror("fork process fail.\n");
    } else if( child ==0  ) {   // in child process
        printf(" fork succ, this run in child process\n ");
    } else {                        // in parent process
        printf(" this run in parent process\n ");
    }
    ```

  - fork() 后，其实是拷贝父进程内容给子进程（只有进程 pid 不同）
    - 数据：刚创建子进程时，父子用户区数据完全相同，但父子后续各自进行不同操作，互不影响，各个进程的数据是独立的
    - 原理解析：进程运行时候，所有的计算都在物理内存中的，父子进程“虚拟地址空间 用户区中的数据”都会通过 MMU 映射到物理内存
    - 问题一：父子进程的数据都会映射到内存中，此时在内存中，会有几分数据？一份（早期的 Linux 系统设计是两份，但那种设计太浪费内存空间）
    - 问题二：那如何实现父子进程的数据独立的？读时共享，写时复制（父子有一个进程对数据进行修改操作，都是先复制出一份，然后修改复制数据）
    - 问题三：父子进程能否通过全局变量进行通信？不能，因为父子的全局变量是相互独立的，进程访问的都是各自的经过复制的变量，内存不能共享，无法通信。
    - PCB 中的文件描述符，内存映射区是共享的。例如：父进程先打开一个文件，此时父进程文件描述符表第 3 号被占用，指向文件，此时 fork ，子进程会拷贝父进程的文件描述符，子进程也指向该文件，意味着父子进程可以操作同一个文件
    - 这种设计的原因：是父子进程通过 pipe，fifo，内存映射区，套接字等实现父子进程通信的基础

#### 抢占式调度

- 抢占式调度和非抢占式调度是操作系统中用于管理任务和资源分配的两种不同策略。
  - `抢占式调度`是指操作系统能够强制中断当前正在执行的任务，并将CPU资源分配给`更高优先级`的任务。在抢占式调度中，任务的执行顺序可以在任何时候被打断，无论任务是否已经完成。这种调度策略使得操作系统能够对任务进行更精确的控制，提高系统的响应速度和吞吐量。然而，`频繁的抢占也可能引起任务切换的开销，降低系统的效率`。
  -  `非抢占式调度`是指任务在开始执行后，只有在任务主动释放CPU资源或者任务执行完毕后，操作系统才会将CPU资源分配给下一个任务。在非抢占式调度中，任务具有更长的执行时间，减少了任务切换的开销。但是，如果一个任务占用了过长时间的CPU资源，其他高优先级的任务可能会等待很长时间才能执行，从而`降低了系统的响应速度`。
-  总之，抢占式调度和非抢占式调度的区别在于`任务是否可以在任意时刻被强制中断`。抢占式调度提供了更灵活的任务管理和更快的响应能力，但可能引起更多的开销；非抢占式调度则具有更低的开销，但可能导致任务响应时间较长。

#### 进程间通讯（IPC）方式

| 类别 | 信号   | 信号量           | 消息队列 | 管道                                            | 共享内存                                 | socket         |
| ---- | ------ | ---------------- | -------- | ----------------------------------------------- | ---------------------------------------- | -------------- |
| 描述 | 软中断 | 计数器，同步互斥 | 消息链表 | 无名管道（父子进程间通信）+有名管道（FIFO文件） | 将同一块内存映射到不同进程（最快最有效） | 面向网络的通信 |
| 流向 |        |                  | 单向     | 单向                                            | 双向                                     |                |

- 信号（Signal）

- 信号量（semaphore）

  - 信号量是一种用于进程同步和互斥的通信机制。它可以用来解决进程之间的竞争条件和资源共享的问题。进程可以使用信号量进行互斥访问，控制对临界资源的访问。

- 报文（Message）队列（消息队列）

  - 消息队列是一种在进程之间传递消息的通信机制。它通过在消息队列中存储消息，使多个进程可以异步地进行通信。每个消息都具有特定的类型和优先级。

- 管道（Pipe）

  - 无名管道（Unnamed Pipe）：
    - 无名管道是一种半双工的、只能在具有公共祖先的进程之间使用的通信机制。
    - 创建无名管道时，操作系统会为其分配一个读端和一个写端。
    - 数据通过管道在进程之间单向流动，一端写入数据，另一端从中读取。
    - 无名管道通常用于父子进程之间的通信，可以通过fork()系统调用创建。
    - 无名管道只能用于有亲缘关系的进程之间的通信，无法被其他进程访问。
  - 有名管道（Named Pipe）：
    - 有名管道也称为FIFO（First In, First Out），它提供了一种在无亲缘关系的进程之间进行通信的方法。
    - 有名管道通过在文件系统中创建一个特殊类型的文件来实现，该文件具有独立的文件名。
    - 不同进程可以通过打开该文件并对其进行读写来进行通信。
    - 有名管道允许多个进程同时向其中写入数据或者从中读取数据。
    - 有名管道可以被许多不相关的进程使用，提供了一种灵活的进程间通信方式。

- 共享内存

  - 共享内存是进程间通信的一种方式。不同进程之间共享的内存通常为同一段物理内存，进程可以将同一段物理内存连接到他们自己的地址空间中，所有的进程都可以访问共享内存中的地址。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。
  - 优点：访问高效，通信时无需内核接入避免不必要的复制
  - 缺点：没有同步机制，需要手动设计

- 套接字（socket）

  - 套接字是一种用于网络通信的IPC机制，它提供了一种标准的网络编程接口。通过套接字，进程可以在不同主机之间进行通信，实现网络应用程序。

  - 用户建立一个socket，指明网络协议、端口号等，在内核中开辟一个空间，返回句柄fd

    用户将数据包用write系统调用传给内核，内核调用网卡驱动发送出去

    对端主机反向处理数据，应用采用read系统调用读取

    ![image-20230708125052374](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230708125052374.png)


#### 线程间通信

- 同步和互斥（信号、互斥锁、读写锁、自旋锁、条件变量、信号量）

  - ==互斥==是指在同一时刻只允许一个访问者对资源进行访问，具有排它性。
  - ==同步==是指在互斥的基础上，通过其他机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥。
  - ==信号== Linux 中使用 pthread_kill() 函数对线程发信号。 
  - ==互斥锁==确保同一时间只能有一个线程访问共享资源，当锁被占用时试图对其加锁的线程都进入阻塞状态（释放 CPU 资源使其由运行状态进入等待状态），当锁释放时哪个等待线程能获得该锁取决于内核的调度。
  - ==读写锁==当以写模式加锁而处于写状态时任何试图加锁的线程（不论是读或写）都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。
  - ==自旋锁==上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对 CPU 的霸占会导致 CPU 资源的浪费。 所以自旋锁适用于并行结构（多个处理器）或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。 
  - ==条件变量== 条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的，条件变量始终与互斥锁一起使用。
    - 线程的阻塞是通过成员函数wait()/wait_for()和wait_until()实现
    - 线程唤醒是通过函数notify_all()和notify_one()实现
    - ==虚假唤醒==：在正常情况下，wait类型函数返回时要么是因为被唤醒，要么是因为超时才返回，但是在实际中发现，因此操作系统的原因，wait类型在不满足条件时，它也会返回，这就导致了虚假唤醒。
  - ==信号量== 信号量实际上是一个非负的整数计数器，用来实现对公共资源的控制。在公共资源增加的时候，信号量就增加；公共资源减少的时候，信号量就减少；只有当信号量的值大于0的时候，才能访问信号量所代表的公共资源。

- 信号量和互斥锁

  - `信号量（Semaphore）`：信号量是一种计数器，用于控制对共享资源的访问。它可以是整数类型的变量，用于记录资源的可用数量或可访问状态。信号量具有两个基本操作：等待（wait）和通知（signal）。
    - 等待（wait）操作：如果信号量的值大于零，则减少其值并继续执行。如果值为零，则等待其他任务释放资源，并阻塞当前任务。
    - 通知（signal）操作：增加信号量的值，表示资源已经可用，并通知等待的任务继续执行。
    - `互斥锁（Mutex）`：互斥锁是一种二进制标志，用于保护共享资源的独占访问。它具有两个状态：锁定（locked）和解锁（unlocked）。
      - 锁定状态：当一个任务获得互斥锁时，其他任务尝试获得该锁将被阻塞，直到持有锁的任务释放锁。
      - 解锁状态：当持有锁的任务释放锁时，其他被阻塞的任务可以尝试获得该锁并继续执行。

- 互斥锁Mutex、自旋锁Spin

  - 当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对
  - 互斥锁：Mutex，独占锁，谁上锁谁有权释放，申请上锁失败后阻塞，不能在中断中调用
  - 自旋锁：Spinlock：申请上锁失败后，一直判断是否上锁成功，消耗CPU资源，可在中断中调用

- 临界区与锁的对比

  互斥锁与临界区的作用非常相似，但互斥锁（mutex）是可以命名的，也就是说它可以跨越进程使用。所以创建互斥锁需要的资源更多，所以如果只为了在进程内部使用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥锁是跨进程的互斥锁一旦被创建，就可以通过名字打开它

  临界区是一种轻量级的同步机制，与互斥和事件这些内核同步对象相比，临界区是用户态下的对象，即只能在同一进程中实现线程互斥。因无需在用户态和核心态之间切换，所以工作效率比较互斥来说要高很多。

  |        | 使用场景             | 操作权限           |
  | ------ | -------------------- | ------------------ |
  | 临界区 | 一个进程下不同线程间 | 用户态，轻量级，快 |
  | 互斥锁 | 进程间或线程间       | 内核态，切换，慢   |

- 阻塞与非阻塞区别

  阻塞：条件不满足时等待，进入阻塞态直到条件满足被唤醒

  非阻塞：条件不满足时立刻返回，继续执行其他任务

#### 进程管理与调度

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/70.png" alt="img" style="zoom: 67%;" />

### ==I/O管理==

#### 系统调用

- 系统调用和函数调用的区别

  | 类别     | 系统调用           | 函数调用               |
  | -------- | ------------------ | ---------------------- |
  | 简介     | 调用内核的服务     | 调用函数库中的一个程序 |
  | 涉及对象 | 程序与内核         | 用户与程序             |
  | 运行空间 | 内核地址空间       | 用户地址空间           |
  | 开销     | 上下文切换，开销大 | 小                     |

- 系统调用read() 、write()内核做了什么

  - 用户空间read()-->内核空间sys_read()-->scull_fops.read-->scull_read()；

    过程分为两个部分：用户空间的处理和内核空间的处理。

    在用户空间中通过 0x80 中断的方式将控制权交给内核处理，

    内核接管后，经过6个层次的处理最后将请求交给磁盘，由磁盘完成最终的数据拷贝操作。在这个过程中，调用了一系列的内核函数。

- 常用系统调用

  * [进程控制函数](#进程控制函数)

  * [文件操作函数](#文件操作函数)

  * [文件系统操作函数](#文件系统操作函数)

  * [系统控制函数](#系统控制函数)

  * [内存管理函数](#内存管理函数)

  * [网络管理函数](#网络管理函数)

  * [socket函数](#socket函数)

  * [用户管理函数](#用户管理函数)

  * [进程间通信函数](#进程间通信函数)

  * [信号相关函数](#信号相关函数)

  * [消息相关函数](#消息相关函数)

  * [管道相关函数](#管道相关函数)

  * [信号量相关函数](#信号量相关函数)

  * [共享内存相关函数](#共享内存相关函数)

##### 进程控制函数

<table>
   <tr style="color:red">
      <td>fork</td>
      <td>创建一个新进程</td>
   </tr>
   <tr style="color:red">
      <td>clone</td>
      <td>按指定条件创建子进程</td>
   </tr>
   <tr style="color:red">
      <td>execve</td>
      <td>运行可执行文件</td>
   </tr>
   <tr style="color:red">
      <td>exit</td>
      <td>中止进程</td>
   </tr>
   <tr>
      <td>_exit</td>
      <td>立即中止当前进程</td>
   </tr>
   <tr>
      <td>getdtablesize</td>
      <td>进程所能打开的最大文件数</td>
   </tr>
   <tr>
      <td>getpgid</td>
      <td>获取指定进程组标识号</td>
   </tr>
   <tr>
      <td>setpgid</td>
      <td>设置指定进程组标志号</td>
   </tr>
   <tr>
      <td>getpgrp</td>
      <td>获取当前进程组标识号</td>
   </tr>
   <tr>
      <td>setpgrp</td>
      <td>设置当前进程组标志号</td>
    </tr>
      <tr style="color:red">
          <td>getpid</td>
          <td>获取进程标识号</td>
    </tr>
      <tr>
          <td>getppid</td>
          <td>获取父进程标识号</td>
    </tr>
      <tr style="color:red">
          <td>getpriority</td>
          <td>获取调度优先级</td>
    </tr>
      <tr style="color:red">
          <td>setpriority</td>
          <td>设置调度优先级</td>
    </tr>
      <tr>
          <td>modify_ldt</td>
          <td>读写进程的本地描述表</td>
    </tr>
      <tr>
          <td>nanosleep</td>
          <td>使进程睡眠指定的时间</td>
    </tr>
      <tr>
          <td>nice</td>
          <td>改变分时进程的优先级</td>
    </tr>
      <tr style="color:red">
          <td>pause</td>
          <td>挂起进程，等待信号</td>
    </tr>
      <tr>
          <td>personality</td>
          <td>设置进程运行域</td>
    </tr>
      <tr style="color:red">
          <td>prctl</td>
          <td>对进程进行特定操作</td>
    </tr>
      <tr>
          <td>ptrace</td>
          <td>进程跟踪</td>
    </tr>
      <tr>
          <td>sched_get_priority_max</td>
          <td>取得静态优先级的上限</td>
    </tr>
      <tr>
          <td>sched_get_priority_min</td>
          <td>取得静态优先级的下限</td>
    </tr>
      <tr>
          <td>sched_getparam</td>
          <td>取得进程的调度参数</td>
    </tr>
      <tr>
          <td>sched_getscheduler</td>
          <td>取得指定进程的调度策略</td>
    </tr>
      <tr>
          <td>sched_rr_get_interval</td>
          <td>取得按RR算法调度的实时进程的时间片长度</td>
    </tr>
      <tr>
          <td>sched_setparam</td>
          <td>设置进程的调度参数</td>
    </tr>
      <tr>
          <td>sched_setscheduler</td>
          <td>设置指定进程的调度策略和参数</td>
    </tr>
      <tr>
          <td>sched_yield</td>
          <td>进程主动让出处理器,并将自己等候调度队列队尾</td>
    </tr>
      <tr>
          <td>vfork</td>
          <td>创建一个子进程，以供执行新程序，常与execve等同时使用</td>
    </tr>
      <tr style="color:red">
          <td>wait</td>
          <td>等待子进程终止</td>
    </tr>
      <tr>
          <td>wait3</td>
          <td>参见wait</td>
    </tr>
      <tr>
          <td>waitpid</td>
          <td>等待指定子进程终止</td>
    </tr>
      <tr>
          <td>wait4</td>
          <td>参见waitpid</td>
    </tr>
      <tr>
          <td>capget</td>
          <td>获取进程权限</td>
    </tr>
      <tr>
          <td>capset</td>
          <td>设置进程权限</td>
    </tr>
      <tr>
          <td>getsid</td>
          <td>获取会晤标识号</td>
    </tr>
      <tr>
          <td>setsid</td>
          <td>设置会晤标识号</td>
      </tr>
</table>

##### 文件操作函数

<table>
  <tr style="color:red">
      <td>fcntl</td>
      <td>文件控制</td>
  </tr>
  <tr style="color:red">
      <td>open</td>
      <td>打开文件</td>
  </tr>
  <tr style="color:red">
      <td>creat</td>
      <td>创建新文件</td>
  </tr>
  <tr style="color:red">
      <td>close</td>
      <td>关闭文件描述字</td>
  </tr>
  <tr style="color:red">
      <td>read</td>
      <td>读文件</td>
  </tr>
  <tr style="color:red">
      <td>write</td>
      <td>写文件</td>
  </tr>
  <tr>
      <td>readv</td>
      <td>从文件读入数据到缓冲数组中</td>
  </tr>
  <tr>
      <td>writev</td>
      <td>将缓冲数组里的数据写入文件</td>
  </tr>
  <tr>
      <td>pread</td>
      <td>对文件随机读</td>
  </tr>
  <tr>
      <td>pwrite</td>
      <td>对文件随机写</td>
  </tr>
  <tr style="color:red">
      <td>lseek</td>
      <td>移动文件指针</td>
  </tr>
  <tr>
      <td>_llseek</td>
      <td>在64位地址空间里移动文件指针</td>
  </tr>
  <tr>
      <td>dup</td>
      <td>复制已打开的文件描述字</td>
  </tr>
  <tr>
      <td>dup2</td>
      <td>按指定条件复制文件描述字</td>
  </tr>
  <tr style="color:red">
      <td>flock</td>
      <td>文件加/解锁</td>
  </tr>
  <tr style="color:red">
      <td>poll</td>
      <td>I/O多路转换</td>
  </tr>
  <tr>
      <td>truncate</td>
      <td>截断文件</td>
  </tr>
  <tr>
      <td>ftruncate</td>
      <td>参见truncate</td>
  </tr>
  <tr>
      <td>umask</td>
      <td>设置文件权限掩码</td>
  </tr>
  <tr style="color:red">
      <td>fsync</td>
      <td>把文件在内存中的部分写回磁盘</td>
  </tr>
</table>

##### 文件系统操作函数

<table>
  <tr style="color:red">
      <td>access</td>
      <td>确定文件的可存取性</td>
  </tr>
  <tr style="color:red">
      <td>chdir</td>
      <td>改变当前工作目录</td>
  </tr>
  <tr>
      <td>fchdir</td>
      <td>参见chdir</td>
  </tr>
  <tr style="color:red">
      <td>chmod</td>
      <td>改变文件方式</td>
  </tr>
  <tr>
      <td>fchmod</td>
      <td>参见chmod</td>
  </tr>
  <tr>
      <td>chown</td>
      <td>改变文件的属主或用户组</td>
  </tr>
  <tr>
      <td>fchown</td>
      <td>参见chown</td>
  </tr>
  <tr>
      <td>lchown</td>
      <td>参见chown</td>
  </tr>
  <tr style="color:red">
      <td>chroot</td>
      <td>改变根目录</td>
  </tr>
  <tr style="color:red">
      <td>stat</td>
      <td>取文件状态信息</td>
  </tr>
  <tr>
      <td>lstat</td>
      <td>参见stat</td>
  </tr>
  <tr>
      <td>fstat</td>
      <td>参见stat</td>
  </tr>
  <tr style="color:red">
      <td>statfs</td>
      <td>取文件系统信息</td>
  </tr>
  <tr>
      <td>fstatfs</td>
      <td>参见statfs</td>
  </tr>
  <tr style="color:red">
      <td>readdir</td>
      <td>读取目录项</td>
  </tr>
  <tr>
      <td>getdents</td>
      <td>读取目录项</td>
  </tr>
  <tr style="color:red">
      <td>mkdir</td>
      <td>创建目录</td>
  </tr>
  <tr style="color:red">
      <td>mknod</td>
      <td>创建索引节点</td>
  </tr>
  <tr style="color:red">
      <td>rmdir</td>
      <td>删除目录</td>
  </tr>
  <tr style="color:red">
      <td>rename</td>
      <td>文件改名</td>
  </tr>
  <tr style="color:red">
      <td>link</td>
      <td>创建链接</td>
  </tr>
  <tr style="color:red">
      <td>symlink</td>
      <td>创建符号链接</td>
  </tr>
  <tr style="color:red">
      <td>unlink</td>
      <td>删除链接</td>
  </tr>
  <tr>
      <td>readlink</td>
      <td>读符号链接的值</td>
  </tr>
  <tr>
      <td>mount</td>
      <td>安装文件系统</td>
  </tr>
  <tr>
      <td>umount</td>
      <td>卸下文件系统</td>
  </tr>
  <tr style="color:red">
      <td>ustat</td>
      <td>取文件系统信息</td>
  </tr>
  <tr>
      <td>utime</td>
      <td>改变文件的访问修改时间</td>
  </tr>
  <tr>
      <td>utimes</td>
      <td>参见utime</td>
  </tr>
  <tr>
      <td>quotactl</td>
      <td>控制磁盘配额</td>
  </tr>
</table>

##### 系统控制函数

<table>
  <tr style="color:red">
      <td>ioctl</td>
      <td>I/O总控制函数</td>
  </tr>
  <tr>
      <td>_sysctl</td>
      <td>读/写系统参数</td>
  </tr>
  <tr>
      <td>acct</td>
      <td>启用或禁止进程记账</td>
  </tr>
  <tr>
      <td>getrlimit</td>
      <td>获取系统资源上限</td>
  </tr>
  <tr>
      <td>setrlimit</td>
      <td>设置系统资源上限</td>
  </tr>
  <tr>
      <td>getrusage</td>
      <td>获取系统资源使用情况</td>
  </tr>
  <tr>
      <td>uselib</td>
      <td>选择要使用的二进制函数库</td>
  </tr>
  <tr>
      <td>ioperm</td>
      <td>设置端口I/O权限</td>
  </tr>
  <tr>
      <td>iopl</td>
      <td>改变进程I/O权限级别</td>
  </tr>
  <tr>
      <td>outb</td>
      <td>低级端口操作</td>
  </tr>
  <tr style="color:red">
      <td>reboot</td>
      <td>重新启动</td>
  </tr>
  <tr>
      <td>swapon</td>
      <td>打开交换文件和设备</td>
  </tr>
  <tr>
      <td>swapoff</td>
      <td>关闭交换文件和设备</td>
  </tr>
  <tr>
      <td>bdflush</td>
      <td>控制bdflush守护进程</td>
  </tr>
  <tr>
      <td>sysfs</td>
      <td>取核心支持的文件系统类型</td>
  </tr>
  <tr>
      <td>sysinfo</td>
      <td>取得系统信息</td>
  </tr>
  <tr>
      <td>adjtimex</td>
      <td>调整系统时钟</td>
  </tr>
  <tr>
      <td>alarm</td>
      <td>设置进程的闹钟</td>
  </tr>
  <tr>
      <td>getitimer</td>
      <td>获取计时器值</td>
  </tr>
  <tr>
      <td>setitimer</td>
      <td>设置计时器值</td>
  </tr>
  <tr>
      <td>gettimeofday</td>
      <td>取时间和时区</td>
  </tr>
  <tr>
      <td>settimeofday</td>
      <td>设置时间和时区</td>
  </tr>
  <tr style="color:red">
      <td>stime</td>
      <td>设置系统日期和时间</td>
  </tr>
  <tr style="color:red">
      <td>time</td>
      <td>取得系统时间</td>
  </tr>
  <tr>
      <td>times</td>
      <td>取进程运行时间</td>
  </tr>
  <tr style="color:red">
      <td>uname</td>
      <td>获取当前UNIX系统的名称、版本和主机等信息</td>
  </tr>
  <tr>
      <td>vhangup</td>
      <td>挂起当前终端</td>
  </tr>
  <tr>
      <td>nfsservctl</td>
      <td>对NFS守护进程进行控制</td>
  </tr>
  <tr>
      <td>vm86</td>
      <td>进入模拟8086模式</td>
  </tr>
  <tr>
      <td>create_module</td>
      <td>创建可装载的模块项</td>
  </tr>
  <tr>
      <td>delete_module</td>
      <td>删除可装载的模块项</td>
  </tr>
  <tr>
      <td>init_module</td>
      <td>初始化模块</td>
  </tr>
  <tr>
      <td>query_module</td>
      <td>查询模块信息</td>
  </tr>
  <tr>
      <td>*get_kernel_syms</td>
      <td>取得核心符号,已被query_module代替</td>
  </tr>
</table>

##### 内存管理函数

<table>
  <tr>
      <td>brk</td>
      <td>改变数据段空间的分配</td>
  </tr>
  <tr>
      <td>sbrk</td>
      <td>参见brk</td>
  </tr>
  <tr>
      <td>mlock</td>
      <td>内存页面加锁</td>
  </tr>
  <tr>
      <td>munlock</td>
      <td>内存页面解锁</td>
  </tr>
  <tr>
      <td>mlockall</td>
      <td>调用进程所有内存页面加锁</td>
  </tr>
    <tr>
      <td>munlockall</td>
      <td>调用进程所有内存页面解锁</td>
  </tr>
  <tr>
      <td>mmap</td>
      <td>映射虚拟内存页</td>
  </tr>
  <tr>
      <td>munmap</td>
      <td>去除内存页映射</td>
  </tr>
  <tr>
      <td>mremap</td>
      <td>重新映射虚拟内存地址</td>
  </tr>
  <tr>
      <td>msync</td>
      <td>将映射内存中的数据写回磁盘</td>
  </tr>
  <tr>
      <td>mprotect</td>
      <td>设置内存映像保护</td>
  </tr>
  <tr>
      <td>getpagesize</td>
      <td>获取页面大小</td>
  </tr>
  <tr style="color:red">
      <td>sync</td>
      <td>将内存缓冲区数据写回硬盘</td>
  </tr>
  <tr>
      <td>cacheflush</td>
      <td>dddd将指定缓冲区中的内容写回磁盘dd</td>
  </tr>
</table>

##### 网络管理函数

<table>
  <tr style="color:red">
      <td>getdomainname</td>
      <td>取域名</td>
  </tr>
  <tr style="color:red">
      <td>setdomainname</td>
      <td>设置域名</td>
  </tr>
  <tr>
      <td>gethostid</td>
      <td>获取主机标识号</td>
  </tr>
  <tr>
      <td>sethostid</td>
      <td>设置主机标识号</td>
  </tr>
  <tr style="color:red">
      <td>gethostname</td>
      <td>获取本主机名称</td>
  </tr>
  <tr style="color:red">
      <td>sethostname</td>
      <td>设置主机名称</td>
  </tr>
</table>

##### socket函数

<table>
  <tr>
      <td>socketcall</td>
      <td>socket系统调用</td>
  </tr>
  <tr style="color:red">
      <td>socket</td>
      <td>建立socket</td>
  </tr>
  <tr style="color:red">
      <td>bind</td>
      <td>绑定socket到端口</td>
  </tr>
  <tr style="color:red">
      <td>connect</td>
      <td>连接远程主机</td>
  </tr>
  <tr style="color:red">
      <td>accept</td>
      <td>响应socket连接请求</td>
  </tr style="color:red">
    <tr>
      <td>send</td>
      <td>通过socket发送信息</td>
  </tr>
  <tr style="color:red">
      <td>sendto</td>
      <td>发送UDP信息</td>
  </tr>
  <tr>
      <td>sendmsg</td>
      <td>参见send</td>
  </tr>
  <tr style="color:red">
      <td>recv</td>
      <td>通过socket接收信息</td>
  </tr>
    <tr style="color:red">
      <td>recvfrom</td>
      <td>接收UDP信息</td>
  </tr>
  <tr>
      <td>recvmsg</td>
      <td>参见recv</td>
  </tr>
  <tr style="color:red">
      <td>listen</td>
      <td>监听socket端口</td>
  </tr>
  <tr style="color:red">
      <td>select</td>
      <td>对多路同步I/O进行轮询</td>
  </tr>
  <tr style="color:red">
      <td>close</td>
      <td>关闭socket上的连接</td>
  </tr>
  <tr>
      <td>getsockname</td>
      <td>取得本地socket名字</td>
  </tr>
  <tr>
      <td>getpeername</td>
      <td>获取通信对方的socket名字</td>
  </tr>
  <tr style="color:red">
      <td>getsockopt</td>
      <td>取端口设置</td>
  </tr>
  <tr style="color:red">
      <td>setsockopt</td>
      <td>设置端口参数</td>
  </tr>
  <tr>
      <td>sendfile</td>
      <td>在文件或端口间传输数据</td>
  </tr>
  <tr>
      <td>socketpair</td>
      <td>创建一对已联接的无名socket</td>
  </tr>
</table>

##### 用户管理函数

<table>
  <tr>
      <td>getuid</td>
      <td>获取用户标识号</td>
  </tr>
  <tr>
      <td>setuid</td>
      <td>设置用户标志号</td>
  </tr>
  <tr>
      <td>getgid</td>
      <td>获取组标识号</td>
  </tr>
  <tr>
      <td>setgid</td>
      <td>设置组标志号</td>
  </tr>
  <tr>
      <td>getegid</td>
      <td>获取有效组标识号</td>
  </tr>
  <tr>
      <td>setegid</td>
      <td>设置有效组标识号</td>
  </tr>
  <tr>
      <td>geteuid</td>
      <td>获取有效用户标识号</td>
  </tr>
  <tr>
      <td>seteuid</td>
      <td>设置有效用户标识号</td>
  </tr>
  <tr>
      <td>setregid</td>
      <td>分别设置真实和有效的的组标识号</td>
  </tr>
  <tr>
      <td>setreuid</td>
      <td>分别设置真实和有效的用户标识号</td>
  </tr>
  <tr>
      <td>getresgid</td>
      <td>分别获取真实的,有效的和保存过的组标识号</td>
  </tr>
  <tr>
      <td>setresgid</td>
      <td>分别设置真实的,有效的和保存过的组标识号</td>
  </tr>
  <tr>
      <td>getresuid</td>
      <td>分别获取真实的,有效的和保存过的用户标识号</td>
  </tr>
  <tr>
      <td>setresuid</td>
      <td>分别设置真实的,有效的和保存过的用户标识号</td>
  </tr>
  <tr>
      <td>setfsgid</td>
      <td>设置文件系统检查时使用的组标识号</td>
  </tr>
  <tr>
      <td>setfsuid</td>
      <td>设置文件系统检查时使用的用户标识号</td>
  </tr>
  <tr>
      <td>getgroups</td>
      <td>获取后补组标志清单</td>
  </tr>
  <tr>
      <td>setgroups</td>
      <td>设置后补组标志清单</td>
  </tr>
</table>

##### 进程间通信函数

<table>
  <tr style="color:red">
      <td>ipc</td>
      <td>进程间通信总控制调用</td>
  </tr>
</table>

##### 信号相关函数

<table>
  <tr>
      <td>sigaction</td>
      <td>设置对指定信号的处理方法</td>
  </tr>
  <tr>
      <td>sigprocmask</td>
      <td>根据参数对信号集中的信号执行阻塞/解除阻塞等操作</td>
  </tr>
  <tr>
      <td>sigpending</td>
      <td>为指定的被阻塞信号设置队列</td>
  </tr>
  <tr>
      <td>sigsuspend</td>
      <td>挂起进程等待特定信号</td>
  </tr>
  <tr style="color:red">
      <td>signal</td>
      <td>参见signal</td>
  </tr>
  <tr style="color:red">
      <td>kill</td>
      <td>向进程或进程组发信号</td>
  </tr>
  <tr>
      <td>*sigblock</td>
      <td>向被阻塞信号掩码中添加信号,已被sigprocmask代替</td>
  </tr>
  <tr>
      <td>*siggetmask</td>
      <td>取得现有阻塞信号掩码,已被sigprocmask代替</td>
  </tr>
  <tr>
      <td>*sigsetmask</td>
      <td>用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替</td>
  </tr>
  <tr>
      <td>*sigmask</td>
      <td>将给定的信号转化为掩码,已被sigprocmask代替</td>
  </tr>
  <tr>
      <td>*sigpause</td>
      <td>作用同sigsuspend,已被sigsuspend代替</td>
  </tr>
  <tr>
      <td>sigvec</td>
      <td>为兼容BSD而设的信号处理函数,作用类似sigaction</td>
  </tr>
  <tr>
      <td>ssetmask</td>
      <td>ANSI C的信号处理函数,作用类似sigaction</td>
  </tr>
</table>

##### 消息相关函数

<table style="color:red">
  <tr>
      <td>msgctl</td>
      <td>消息控制操作</td>
  </tr>
  <tr>
      <td>msgget</td>
      <td>获取消息队列</td>
  </tr>
  <tr>
      <td>msgsnd</td>
      <td>发消息</td>
  </tr>
  <tr>
      <td>msgrcv</td>
      <td>取消息</td>
  </tr>
</table>

##### 管道相关函数

<table style="color:red">
  <tr>
      <td>pipe</td>
      <td>创建管道</td>
  </tr>
</table>

##### 信号量相关函数

<table style="color:red">
  <tr>
      <td>semctl</td>
      <td>信号量控制</td>
  </tr>
  <tr>
      <td>semget</td>
      <td>获取一组信号量</td>
  </tr>
  <tr>
      <td>semop</td>
      <td>信号量操作</td>
  </tr>
</table>

##### 共享内存相关函数

<table style="color:red">
  <tr>
      <td>shmctl</td>
      <td>控制共享内存</td>
  </tr>
  <tr>
      <td>shmget</td>
      <td>获取共享内存</td>
  </tr>
  <tr>
      <td>shmat</td>
      <td>连接共享内存</td>
  </tr>
  <tr>
      <td>shmdt</td>
      <td>拆卸共享内存</td>
  </tr>
</table>

#### 常见文件说明

```
/var/log/boot.log 系统引导日志
/var/log/dmesg    系统核心启动日志
/var/log/messages 核心系统日志
/var/log/maillog  邮件系统日志
/var/log/xferlog  FTP系统日志
/var/log/syslog   系统出问题的日志
/var/log/secure   安全信息和系统登录与网络连接的信息
/var/log/wtmp     登录记录
/var/spool/clientmqueue
/proc/interrupts
/etc/fstab        Linux内核引导时,从文件/etc/fstab 中读取要加载的文件系统.

proc文件系统是一个伪文件系统，它只存在内存当中。
/proc/buddyinfo   每个内存区中的每个order有多少块可用，和内存碎片问题有关
/proc/cmdline     启动时传递给kernel的参数信息
/proc/cpuinfo     cpu的信息
/proc/crypto      内核使用的所有已安装的加密密码及细节
/proc/devices     已经加载的设备并分类
/proc/dma         已注册使用的ISA DMA频道列表
/proc/execdomains Linux内核当前支持的execution domains
/proc/fb          帧缓冲设备列表，包括数量和控制它的驱动
/proc/filesystems 内核当前支持的文件系统类型
/proc/interrupts  x86架构中的每个IRQ中断数
/proc/iomem       每个物理设备当前在系统内存中的映射
/proc/ioports     一个设备的输入输出所使用的注册端口范围
/proc/kcore       代表系统的物理内存，存储为核心文件格式，里边显示的是字节数，等于RAM大小加上4kb
/proc/kmsg        记录内核生成的信息，可以通过/sbin/klogd或/bin/dmesg来处理
/proc/loadavg     根据过去一段时间内CPU和IO的状态得出的负载状态，与uptime命令有关
/proc/locks       内核锁住的文件列表
/proc/mdstat      多硬盘，RAID配置信息(md=multiple disks)
/proc/meminfo     RAM使用的相关信息
/proc/misc        其他的主要设备(设备号为10)上注册的驱动
/proc/modules     所有加载到内核的模块列表
/proc/mounts      系统中使用的所有挂载
/proc/mtrr        系统使用的Memory Type Range Registers (MTRRs)
/proc/partitions  分区中的块分配信息
/proc/pci         系统中的PCI设备列表
/proc/slabinfo    系统中所有活动的 slab 缓存信息
/proc/stat        所有的CPU活动信息
/proc/sysrq-trigger 使用echo命令来写这个文件的时候，远程root用户可以执行大多数的系统请求关键命令，就好像在本地终端执行一样。要写入这个文件，需要把/proc/sys/kernel/sysrq不能设置为0。这个文件对root也是不可读的
/proc/uptime      系统已经运行了多久
/proc/swaps       交换空间的使用情况
/proc/version     Linux内核版本和gcc版本
/proc/bus         系统总线(Bus)信息，例如pci/usb等
/proc/driver      驱动信息
/proc/fs          文件系统信息
/proc/ide         ide设备信息
/proc/irq         中断请求设备信息
/proc/net         网卡设备信息
/proc/scsi        scsi设备信息
/proc/tty         tty设备信息
/proc/net/dev     显示网络适配器及统计信息
/proc/vmstat      虚拟内存统计信息
/proc/vmcore      内核panic时的内存映像
/proc/diskstats   取得磁盘信息
/proc/schedstat   kernel调度器的统计信息
/proc/zoneinfo    显示内存空间的统计信息，对分析虚拟内存行为很有用
#### 以下是/proc目录中进程N的信息
/proc/N           pid为N的进程信息
/proc/N/cmdline   进程启动命令
/proc/N/cwd       链接到进程当前工作目录
/proc/N/environ   进程环境变量列表
/proc/N/exe       链接到进程的执行命令文件
/proc/N/fd        包含进程相关的所有的文件描述符
/proc/N/maps      与进程相关的内存映射信息
/proc/N/mem       指代进程持有的内存，不可读
/proc/N/root      链接到进程的根目录
/proc/N/stat      进程的状态
/proc/N/statm     进程使用的内存的状态
/proc/N/status    进程状态信息，比stat/statm更具可读性
/proc/self        链接到当前正在运行的进程
```



### ==虚拟文件系统==

#### 概念

- 文件系统是操作系统用于组织和管理文件和目录的方法。它定义了文件的命名规则、存储结构、访问权限和操作方式等。文件系统提供了对文件和目录的创建、读取、写入、删除和修改等操作，并提供了文件的组织结构和层次化的目录结构。文件系统使用户和应用程序能够方便地管理和访问存储在磁盘或其他存储介质上的数据。

- 隐藏硬件的细节，采用vfs_read，vfs_write等接口

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/70-16709319228729.png" alt="img" style="zoom: 67%;" />

![image-20230706162608465](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230706162608465.png)

#### 目录结构

```
- /bin 存放系统可执行文件（大部分系统命令）
- /sbin 存放 root 用户的系统可执行文件
- /boot 存放内核和启动程序的相关文件
- /lib 库目录，存放系统最基本的动态库
- /meida 默认挂载设备媒体的目录，例如： U 盘、光驱
- /mnt 推荐挂载设备媒体的目录
- /usr 用于存放庞大而复杂的目录（ unix system resource ， 用于安装软件的目录）
- /porc 系统内存的映射（随着系统的运行，时长变化的）
- /etc 系统软件的启动和配置目录
- /dev 用于存放设备文件
- /home 家目录，所有用户的根目录
```

#### 文件描述符表

- 内核区-->进程管理 --> PCB 进程控制块（超⼤结构体） --> ⽂件描述符表（⽤于寻磁盘⽂件） ⼀个进程会对应⼀个⽂件描述符表，每打开⼀个⽂件会占⽤⼀个位置 ⼀个⽂件描述表本质上是⼀个数组，最多可以容纳 1024（编号： 0-1023）个⽂件描述符 前 3 个（0-2）默认是打开状态的（被占⽤），分别的标准输⼊、标准输出、标准错误

#### 文件系统类型

<table style="text-align:center">
   <tr>
      <td>fat</td>
      <td>fat32</td>
      <td>ntfs</td>
      <td>ext2</td>
      <td>ext3</td>
      <td>ext4</td>
      <td>nfs</td>
   </tr>
</table>

- 文件系统组成
  - <strong>超级块</strong>：存放文件系统本身的信息，比如记录了每个区域的大小，或未被使用的磁盘块的信息。（不同版本稍有差别）
  - <strong>i-节点表</strong>：每个文件都有其属性，大小，最近修改时间等等，这些被存储在ino_t 的结构体中，所有的i-节点都有一样的大小，i-节点表就是这样一些节点的列表。（表中的每个i-节点都通过位置来标志，例如标志为2的i-节点位于文件系统i-节点表中的第3个位置 ）
  - <strong>数据块</strong>：存放文件内容，因为块的大小一定，所以有时一个文件会分布在多个磁盘上。

#### 7种文件类型

- 普通文件类型 [-]

  Linux中最多的一种文件类型, 包括 纯文本文件；二进制文件；数据格式的文件；各种压缩文件。第一个属性为 [-]

-  目录文件[d]

   就是目录， 能用 cd 命令进入的。第一个属性为 [d]

-  块设备文件[b]

   块设备文件 ： 硬盘。例如一号硬盘的代码是 /dev/hda1等文件。第一个属性为 [b]

-  字符设备[c]

   即串行端口的接口设备，例如键盘、鼠标等等。第一个属性为 [c]

-  套接字文件[s]

   这类文件通常用在网络数据连接。可以启动一个程序来监听客户端的要求，客户端就可以通过套接字来进行数据通信。第一个属性为 [s]，最常在 /var/run目录中看到这种文件类型

-  管道文件 [p]

   FIFO也是一种特殊的文件类型，它主要的目的是，解决多个程序同时存取一个文件所造成的错误。第一个属性为 [p]

-  链接文件 [l]

   类似Windows下面的快捷方式。第一个属性为 [l]

#### 软链接和硬链接

- 系统中只有一份数据，若一个用户修改，其他用户可以同步感知

  硬链接：通过索引节点来进行链接。磁盘中的文件具有的索引编号（Inode）（允许一个文件拥有多个有效路径名）

  ![img](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/824470-20180531151753197-400006785.png)

  1. 以文件副本的形式存在。但不占用实际空间。
  2. 不允许给目录创建硬链接。
  3. 硬链接只有在同一个文件系统中才能创建。
  4. 删除其中一个硬链接文件并不影响其他有相同 inode 号的文件。
  5. 不同用户看来文件名可以不同
  6. 硬链接直接指向文件的i节点
  7. 硬链接和原文件的i节点是一样的
  8. 硬链接文件显示的大小是跟原文件是一样的
  9. 硬链接不能链接目录文件。

  ```sh
  ln file2 /home/xiaxiaowen/file2hard
  ```

  软连接：（符号连接，快捷方式）软链接就是一个普通文件，存放另一文件的路径

  1. 软链接是存放另一个文件的路径的形式存在。
  2. 可以跨文件系统 
  3. 可以对一个不存在的文件名进行链接，硬链接必须要有源文件。
  4. 可以对目录进行链接。
  5. 软链接则是建立了一个新文件
  6. 这个文件指向链接的文件，i节点不一样
  7. 可以链接目录

  ```sh
  ln -s file2 /home/xiaxiaowen/file2soft
  ```

  ```shell
  [oracle@Linux]$ touch f1          #创建一个测试文件f1  原有文件
  [oracle@Linux]$ ln f1 f2          #创建f1的一个硬连接文件f2  ln 源地址 目标地址
  [oracle@Linux]$ ln -s f1 f3       #创建f1的一个符号连接文件f3  ln -s 源地址 目标地址
  [oracle@Linux]$ ls -li            # -i参数显示文件的inode节点信息
  total 0
  9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f1
  9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f2
  9797649 lrwxrwxrwx  1 oracle oinstall 2 Apr 21 08:11 f3 -> f1
  #硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 9797648，然而符号连接文件的 inode 节点不同。
  ```

  ```shell
  [oracle@Linux]$ echo "I am f1 file" >>f1
  [oracle@Linux]$ cat f1
  I am f1 file
  [oracle@Linux]$ cat f2
  I am f1 file
  [oracle@Linux]$ cat f3
  I am f1 file
  [oracle@Linux]$ rm -f f1
  [oracle@Linux]$ cat f2
  I am f1 file
  [oracle@Linux]$ cat f3
  cat: f3: No such file or directory
  #当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f3 文件无效
  ```

  ![image-20230706161728700](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230706161728700.png)

#### Linux权限

- 文件角色有3种：

  - 文件拥有者 ：谁创建这文件谁就是拥有者；
  - 文件所属组 ：所有用户都要隶属于某一个组，哪怕只有一个人；
  - 其他人 ：除了拥有者之外的人都是other。

  **更改拥有者 ：** 需要 sudo 提升到管理员身份才能修改

  **更改所属组 ：**sudo [chgrp](https://so.csdn.net/so/search?q=chgrp&spm=1001.2101.3001.7020) yz func.c 

  权限数字定义

  - rwx = 4 + 2 + 1 = 7

  - rw = 4 + 2 = 6

  - rx = 4 +1 = 5


  即

  - 若要同时设置 rwx (可读写运行） 权限则将该权限位 设置 为 4 + 2 + 1 = 7

  - 若要同时设置 rw- （可读写不可运行）权限则将该权限位 设置 为 4 + 2 = 6

  - 若要同时设置 r-x （可读可运行不可写）权限则将该权限位 设置 为 4 +1 = 5

### ==网络接口==

#### 概念

- 分为网络协议和网络驱动程序

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/70-167093197638612.png" alt="img" style="zoom:67%;" />



































- 系统调用
  - 系统调用是什么：系统调用是操作系统提供给应用程序的编程接口，应用程序可以通过系统调用请求操作系统提供的服务和功能。它们是应用程序与操作系统之间的桥梁，允许应用程序访问底层的操作系统资源和执行特权操作。
    - 系统调用的作用是什么：系统调用的作用是使应用程序能够执行与操作系统相关的操作，例如文件操作、进程管理、网络通信、内存管理等。通过系统调用，应用程序可以向操作系统发出请求，以获得所需的服务和资源。系统调用通常提供了一系列参数，应用程序可以设置这些参数来指定所需的操作和数据。
    - 系统调用的工作原理：操作系统在收到系统调用请求时，会切换到内核模式，并执行相应的内核代码来满足应用程序的请求。内核会进行必要的权限检查和资源管理，以确保系统的安全性和稳定性。一旦操作完成，操作系统将结果返回给应用程序，并将控制权转回用户模式，应用程序继续执行。

### ==bootloder==

#### 启动顺序

- bootloader->linuxkernel->rootfile
- u-boot：初始化硬件，将内核装载入RAM，设置SP与PC，准备启动内核
- kernel：（底层驱动向内核注册，上层应用向内核调用）启动并挂载rootfile（存放了文件、库、命令）
- rootfile：业务涉及的文件系统

#### 源码目录
​	api：	存放uboot提供的接口函数
​	arch：	存放跟芯片相关的文件
​	board：	开发板配置文件
​	common:	uboot命令行下支持的命令
​	disk：	磁盘支持
​	doc：	文件目录
​	drivers:设备驱动程序
​	examples例程
​	fs:	支持的文件系统，cramfs fat fdos jffs2 registerfs
​	include:uboot使用到的头文件
​	lib_xxx:与体系结构相关的库文件
​	net:	网络协议栈相关的文件 BOOTP TFTP RARP NFS
​	tools:	工具 mkimage crc

#### 启动流程：
​	stage1：cpu 硬件初始化，汇编实现，加载U-Boot到RAM空间 设置堆栈 跳转到stage2
​	stage2：一般主函数是lib_arm/board.c中的start_armboot。
​		调用一系列的初始化函数
​		将内核从flash复制到ram中
​		进入uboot命令行
​		调用内核

#### bootloader启动流程

- 上电后运行的第一个程序：bootloader（u-boot）（universal bootloader）

  - 典型嵌入式系统的部署：uboot程序（类似BIOS）部署在Flash(能作为启动设备的NorFlash)上、OS部署在FLash(嵌入式系统中用Flash代替了硬盘)上、内存在掉电时无作用，CPU在掉电时不工作。
  - 启动过程：嵌入式系统上电后先执行uboot、然后uboot负责初始化DDR，初始化Flash，然后将OS从Flash中读取到DDR中，然后启动OS(OS启动后uboot就无用了) 总结：嵌入式系统和PC机的启动过程几乎没有两样，只是BIOS成了uboot，硬盘成了Flash。

  Stage1（汇编实现，依赖cpu体系结构初始化）

  ​		进行硬件的初始化（watchdog,ram初始化）
  ​		为Stage2加载代码准备RAM空间
  ​		复制Stage2阶段代码到RAM空间
  ​		设置好栈
  ​		跳转到第二阶段代码的入口点

  Stage2（c语言实现，具有好的可读性和移植性）

  ​		初始化该阶段所用到的硬件设备。
  ​		检测系统内存映射。
  ​		将uImage ,Rootfs，dtb文件从flash读取到RAM内存中。
  ​		设置内核启动参数。（如通过寄存器传递设备树文件的内存地址）

#### Linux启动流程

- 系统上电--->bootrom--->uboot--->kernel加载--->init--->应用程序

- 引导加载程序（Bootloader）启动：U-Boot 被加载到内存中执行。 U-Boot 提供了一个命令行界面，用户可以在这个界面上进行配置和操作。
- 加载内核和备树文件：通过 U-Boot 的命令，加载 Linux 内核kernel）和设备树（device tree）文件到内存中4. 启动 Linux 内核：U-Boot控制权交给 Linux 内核，内核开始执行。内核会初始化系统硬设置页表、启动调度器等。
- 启动 init 进：在内核初始化完成后，内核会执行 init 进程，init 进程是用户空间的第一个进程。 init 进程负责启动其他系统服务，并根据配置加载所需的模块。
- 用户空间初始化：init 进程会根据配置启动用户空间的各个进程和服务，完成系统的初始化。

##  Linux驱动

### 概念

- 设备驱动程序是一种软件模块，用于操作系统与硬件设备之间的通信和交互。它们充当了操作系统与硬件设备之间的桥梁，使操作系统能够管理和控制各种硬件设备。

- 字符设备、块设备、网络设备

  字符设备：操纵并读取硬件状态

  块设备：存储功能，写入数据再读取，数据传输单位是扇区

  ![image-20230708120156845](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230708120156845.png)

![image-20230708115833093](F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230708115833093.png)

逻辑设备表

<img src="F:/本专业/计算机/笔记/嵌入式/嵌入式/嵌入式笔记.assets/image-20230708115847593.png" alt="image-20230708115847593" style="zoom:50%;" />

记录了逻辑设备名称与物理设备名称的对应关系以及驱动程序入口地址

- 设备树
  - Linux设备树（Device Tree）是一种**描述硬件设备和设备间关系的数据结构**，用于在嵌入式系统中配置和管理硬件。它是**一种与平台无关的机制**，它将硬件设备的相关信息以一种可移植的格式储存在一个或多个设备树文件中。
  - 设备树文件是以一种层级结构的形式描述硬件设备及其属性。它包含了设备的类型、寄存器地址、中断、时钟等信息，以及设备间的关系和依赖关系。通过解析设备树文件，内核可以获取设备的配置信息，并正确地初始化和管理硬件设备。

### 驱动开发流程

1. 了解硬件设备及其规范：首先要对目标硬件设备进行研究，包括芯片型号、外设接口、寄存器规范等。同时，对于设备的功能和特性也需要有基本的了解。
2. 编写设备树（Device Tree）描述文件：Linux内核使用设备树来描述硬件设备的信息。需要编写设备树描述文件，以便内核能够识别和配置硬件设备。
3. 编写驱动程序源码：根据设备的规格和需求，编写对应的驱动程序源码。通常需要涉及到底层寄存器的读写、中断处理、设备初始化和资源分配等操作。
4. 将驱动程序源码添加到内核源码树：将驱动程序源码添加到Linux内核源码树，并在内核配置选项中选择该驱动模块进行编译。
5. 构建并刷写内核镜像：完成驱动程序源码的添加和内核配置后，进行内核的构建。通过编译得到的内核镜像可以刷写到目标嵌入式设备上。
6. 调试和测试：将构建好的内核镜像刷写到目标设备，并进行调试和测试。检查设备与驱动之间的通信，确保驱动程序能够正确地初始化设备并提供所需的功能。
7. 优化和性能测试：根据实际使用情况对驱动程序进行优化，并进行性能测试。通过性能测试来评估驱动程序的性能，并进行必要的调整和优化。

### 驱动开发注意事项

- 不能访问C库
- 只有一个很小的定长堆栈
- 没有内存保护机制
- 浮点数很难使用，应该使用整型数

### 驱动开发主要数据结构

- file_operations

  - | 函数        | 说明                   |
    | ----------- | ---------------------- |
    | `open()`    | 打开设备               |
    | `release()` | 释放设备               |
    | `read()`    | 读设备                 |
    | `write()`   | 写设备                 |
    | `ioctl()`   | 对设备设置控制参数     |
    | `llseek()`  | 修改文件当前的读写位置 |
    | `poll()`    | 查询设备是否可读可写   |



## Linux源码阅读

### 内核Makefile

- `Makefile` : 顶层Makefile。
- `.config`: kernel配置文件。
- `arch/xxx/Makefile`: 具体架构的Makefile。
- `scripts/Makefile.xxx` : 通用规则。
- `kbuild Makefile`: 整个kernel中大约有数百个这种文件。

### Kconfig

- 描述了所属目录源文档相关的内核配置菜单，用于make menuconfig中的配置

  - ```
    menu "Network device support"
    config NETDEVICES
        bool "Enable Net Devices"  菜单类型
        depends on NET             该项依赖项，如果没有选中NET，则不会显示这项菜单。
            default y              默认yes
            help                   帮助信息
                This is help desciption。
        ...
        endmenu
    ```

### 内核编译操作

```
make bzImage                    # 编译生成压缩的内核二进制文件
make vmlinux                    # 编译生成二进制内核文件
make modules                    # 编译生成内核模块
make modules_install # 安装模块
make bzdisk|fdimage|isoimage    # 编译生成启动软盘镜像或者光盘镜像
make install                    # 安装内核文件
make all                        # 相当于vmlinux+modules+bzImage
make rpm                        # 构建内核rpm包
make foo/bar/foobar.ko          # 编译单个驱动
make header_install             # 安装内核头文件
make M=some/sub/dir             # 编译指定目录
make O=/path/to/some/dir        # 指定生成的文件放到该目录
make kernelversion              # 输出内核版本信息
make kernelrelease              # 输出内核发行标识
make rpm-pkg|deb-pkg|tar-pkg|targz-pkg|tarbz2-pkg   # 构建这种格式的内核包
make clean                      # 清除生成文件（保留.config和部分模块文件）
make mrproper                   # 清除全部文件（包括.config和备份文件）
make distclean                  # 在make mrproper上还清除编辑器其他的备份文件
```

